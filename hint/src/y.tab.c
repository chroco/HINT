extern char *malloc(), *realloc();

# line 6 "cmd.y"
#include <stdio.h>
#include <math.h>
#include <sys/types.h>
#include <sys/times.h>
#define GL extern
#include "sds.h"

extern yylineno;		/* line number in screen def. source */
char *att = NULL;		/* attrib of property, used to enter rules */
int att_num = 0;

list_of_vars *tmp_vars=NULL;


# line 21 "cmd.y"
typedef union  {
  int intV;
  double doubV;
  char chV;
  Str255 strV;
  char *chpV;
  list_of_vars *varL;
  list_of_str *strL;
  list_of_num *numL;
  list_of_q *strQ;
  fa_type faV;
  ga_error_type gaeV;
  ga_policy_type gapV;
  eval_method_type evalV;
  coloring_type colV;
  er_type erV;
} YYSTYPE;
# define ADD 257
# define AND 258
# define VAR 259
# define QUIT 260
# define DEL 261
# define LIST 262
# define VARS 263
# define DEPENDS 264
# define ON 265
# define IN 266
# define IS 267
# define STRUCTURE 268
# define OF 269
# define FAM 270
# define FOR 271
# define RULE 272
# define ALL 273
# define DESCRIPTIONS 274
# define SET 275
# define CURRENT 276
# define SHOW 277
# define OPT 278
# define NODE 279
# define DERIVE 280
# define SEL 281
# define LOAD 282
# define UNDEF 283
# define TEST 284
# define EVALUATE 285
# define EXPECT 286
# define COMMENT 287
# define LEARN 288
# define STAT 289
# define GA 290
# define POPULATION 291
# define POINTS 292
# define PLOT 293
# define MAN 294
# define WAIT 295
# define DEBUG 296
# define ITERATIONS 297
# define LEX 298
# define PRINT 299
# define FREQ 300
# define ERROR 301
# define MAX 302
# define YECHO 303
# define SAVE 304
# define IMP 305
# define WEIGHT 306
# define MIN 307
# define MULT 308
# define INFORMATIVITY 309
# define GAABS 310
# define YES 311
# define NO 312
# define PREFER 313
# define MUTATION 314
# define POLICY 315
# define CUSTOM 316
# define OR 317
# define LSQR 318
# define RESET 319
# define CROSSOVER 320
# define USAGE 321
# define NORM 322
# define WIDTH 323
# define TABLE 324
# define SPLIT 325
# define DECOMPOSE 326
# define REDO 327
# define GAMMA 328
# define TS 329
# define USING 330
# define CL 331
# define SIGM 332
# define KNN 333
# define COLOR 334
# define COMPUTE 335
# define ONE 336
# define COMPOSE 337
# define HEURISTIC 338
# define COPY 339
# define TO 340
# define QUALITATIVE 341
# define FROM 342
# define QUANTITATIVE 343
# define COMPARE 344
# define STEP 345
# define REPEAT 346
# define YLOG 347
# define GR 348
# define GINI 349
# define RELIEFF 350
# define FUZZY 351
# define CRISP 352
# define PREFIX 353
# define JOIN 354
# define INTERVAL 355
# define INSTANCE 356
# define TREE 357
# define DM 358
# define PJOIN 359
# define FJOIN 360
# define SURE 361
# define NEED 362
# define REDUNDANT 363
# define VECT 364
# define SAME 365
# define GROUP 366
# define ANALYZE 367
# define NAMES 368
# define WRITE 369
# define DIFFERENT 370
# define SOFT 371
# define MNUMBER 372
# define DOT 373
# define COUNT 374
# define LOCAL 375
# define GLOBAL 376
# define SDTIC 377
# define DFC 378
# define DTIC 379
# define CM 380
# define MERGE 381
# define PAIRS 382
# define LAPLACE 383
# define CLUSTER 384
# define NOISE 385
# define SEED 386
# define DONTCARE 387
# define DONTKNOW 388
# define APRIORY 389
# define DISTRIBUTION 390
# define CV 391
# define SAMPLE 392
# define SORT 393
# define MDL 394
# define LEAF 395
# define NOD 396
# define DUPLICATE 397
# define EXPAND 398
# define NUM 399
# define INUM 400
# define STRING 401
# define FNAME 402
# define ID 403
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
extern int yychar;
extern int yyerrflag;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
YYSTYPE yylval, yyval;
# define YYERRCODE 256

# line 1223 "cmd.y"


yyerror()
{
  if (!interact_mode) {
    printf("Syntax error detected in line %d\n",yylineno);
    ++n_errors;
  }
}
int yyexca[] ={
-1, 0,
	10, 6,
	-2, 0,
-1, 1,
	0, -1,
	-2, 6,
-1, 8,
	340, 331,
	-2, 298,
-1, 69,
	266, 293,
	125, 293,
	41, 293,
	-2, 308,
-1, 70,
	340, 332,
	37, 335,
	-2, 300,
-1, 71,
	340, 333,
	37, 336,
	-2, 301,
-1, 72,
	340, 334,
	-2, 299,
-1, 666,
	125, 302,
	-2, 308,
-1, 676,
	10, 322,
	125, 322,
	-2, 311,
-1, 708,
	400, 311,
	-2, 327,
-1, 729,
	10, 321,
	125, 321,
	-2, 311,
-1, 746,
	400, 311,
	-2, 326,
	};
# define YYNPROD 341
# define YYLAST 900
int yyact[]={

   704,   709,    15,   708,   617,    57,   677,   141,   245,   676,
   308,   460,   678,    16,    16,    86,   253,    79,   381,   143,
    87,   219,    90,   233,    91,    89,    88,   151,   147,   150,
    95,   260,   149,   188,   277,   175,   442,   187,   185,   189,
   192,   158,   761,   190,   309,   310,   120,   513,   280,   159,
   367,   178,   179,   423,   204,   193,   755,   223,   224,   168,
   108,   399,   749,   462,   148,   231,   115,   461,   432,   210,
   262,   261,   263,   116,   186,   527,    92,   153,   117,   526,
   213,   152,   741,   212,   113,   132,    98,   107,   740,   119,
   118,   338,   111,   206,   205,   207,   737,   155,   735,   727,
   422,   342,   140,   142,   339,   217,   725,   724,    97,    94,
   100,   145,   302,   146,   112,   273,   341,   296,    99,   234,
   713,   176,   122,   692,   235,   259,   121,   160,   691,   343,
   195,   433,   690,   689,   110,   351,   467,   174,   686,   208,
   685,    93,   301,   683,   682,   672,   114,   668,   209,   303,
   145,   358,   218,    80,   232,    96,   643,    78,   642,   641,
   123,   145,   172,   640,   340,   639,    82,   379,   191,   198,
   197,   196,    85,   124,   161,   125,   126,   109,   127,   128,
   129,   391,   368,   392,   634,   632,   169,    72,   297,   395,
   170,   292,   293,   298,   295,   299,   294,   512,   400,   173,
   628,   178,   179,   627,   624,   184,   620,   616,   615,   612,
   154,   604,   602,   580,   570,   199,   300,   177,    83,   182,
   133,   254,   200,   561,   164,   558,   556,   337,   553,   760,
   550,   542,   538,   171,   523,   178,   179,   522,   521,   257,
   519,   518,   517,   516,   515,   514,   506,   455,   451,   450,
   449,   448,   438,   437,   436,   435,   434,    84,   424,   421,
   446,   418,   415,   414,   413,   412,   411,   410,   403,   402,
   401,   393,   390,   389,   388,   375,   374,   371,   359,   356,
   355,   354,   352,   311,   288,   278,   268,   267,   266,   264,
   258,   255,   250,   221,   211,   203,   202,    81,   201,   194,
   156,   465,   466,   131,   130,   106,   178,   179,   753,   244,
   710,   744,   738,   695,   633,   473,   474,   475,   476,   603,
   582,   581,   547,   546,   279,   215,   545,   511,   281,   544,
   543,   180,   478,   477,   181,   471,   470,   394,   350,   283,
   752,   748,   721,   720,   711,   500,   501,   674,   664,   660,
   659,   658,   657,   656,   382,   383,   655,   505,   380,   654,
   508,   653,   652,   650,   649,   647,   646,   621,   510,   586,
   275,   276,   440,   441,   274,   552,   439,   549,   531,   472,
     4,     5,   464,    63,    68,     6,     7,   430,   429,   376,
   243,   229,   228,   167,    21,   431,    26,   384,   535,    10,
   216,    25,    64,   503,    18,    24,    45,    43,    29,    42,
    41,     3,    19,    46,   136,   671,   670,    20,   282,    65,
    61,   135,   313,   314,   540,   242,   315,    66,    33,    27,
   286,   241,   734,     9,   557,   406,   559,    62,   102,   623,
   239,   722,   240,    28,   719,   610,   345,   609,   525,    34,
    40,   420,   104,   398,   718,   569,   166,   571,    67,   572,
    48,    47,   567,    32,   469,    11,   715,    12,    13,   714,
   573,    36,   712,   684,   408,   407,   409,   227,    49,    17,
    44,    35,   502,    50,    51,    53,    54,   680,    22,    55,
   637,    52,   285,    60,    56,   304,   635,   626,    14,   565,
   564,    38,    37,    39,   563,    30,    58,   562,   165,   344,
    59,   541,   348,   349,   560,   457,   608,    23,   419,   405,
   346,   347,    31,    70,    71,   287,   290,     8,   396,   353,
   138,    72,   226,   334,   307,   306,   305,   134,   225,   611,
   607,   318,   622,   335,   554,   222,   468,   364,   699,   698,
   629,   625,   555,   539,   536,   324,   631,   507,   316,   463,
   385,   362,   271,   597,   317,   387,   320,   309,   310,   601,
   493,   330,   498,   319,   372,   481,   291,   497,   499,   326,
   489,   322,   325,   163,   490,   480,   479,   323,   289,   648,
   321,   486,   483,   214,   162,   487,   484,   238,   613,   256,
   363,   269,   754,   614,   661,   662,   663,   183,   236,   454,
   157,   551,   667,   237,   534,   533,   491,   532,   524,   520,
   504,   599,   598,   452,   679,   447,   417,   488,   485,   681,
   373,   370,   369,   366,   361,   360,   270,   220,   428,   426,
   377,   265,   759,   638,   636,   537,   139,   252,   137,   427,
   425,   509,   458,   548,   272,   101,    77,   750,   736,   687,
   103,   651,   630,   577,   751,   745,   728,   726,   696,   669,
   645,   644,   605,   688,   673,   697,   700,   445,   619,   445,
   702,   606,   529,   456,   357,   251,   701,   600,   758,   595,
   575,   594,   593,   717,   495,   716,   743,   592,   591,   590,
   589,   588,   587,   723,   585,   579,   584,   583,   492,   733,
   482,   730,   731,   729,   416,   386,   378,   333,   578,   705,
   739,   742,   694,   693,   365,     5,   762,    63,    68,     6,
     7,   248,   756,   105,   706,   747,   746,   757,    21,   568,
    26,   574,   528,    10,   576,    25,    64,   733,    18,    24,
    45,    43,    29,    42,    41,    74,    19,    46,   566,   453,
   444,    20,   494,    65,    61,   246,   404,   397,   230,   732,
   618,    66,    33,    27,   703,   249,    76,     9,    75,   707,
   247,    62,     2,   530,    73,   675,     1,    28,   284,   336,
   312,   596,   327,    34,    40,   496,   459,   144,   666,   665,
    69,     0,    67,     0,    48,    47,     0,    32,     0,    11,
     0,    12,    13,     0,     0,    36,     0,     0,     0,     0,
     0,     0,    49,    17,    44,    35,     0,    50,    51,    53,
    54,     0,    22,    55,     0,    52,   331,    60,    56,     0,
     0,     0,    14,     0,   328,    38,    37,    39,     0,    30,
    58,     0,   329,     0,    59,     0,   332,     0,     0,     0,
     0,    23,     0,     0,     0,     0,    31,    70,    71,     0,
     0,     8,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   443 };
int yypact[]={

   124,   468,   768, -1000,   766,   397,  -106,  -248,   391,   -98,
  -212,   -99,  -100,  -183,   142,   382,   190,   377,  -253,  -242,
  -193,  -103, -1000,   338,  -229,   318,   184,    -6,  -213,  -164,
   -66,   335,  -198,  -235,  -348,  -104,  -179,  -105,  -107,  -108,
  -255,  -109,  -320,   315,     1,  -251,   366,  -110,   219,  -292,
  -292, -1000,   204,   198,   143,    -7,    -8,   731, -1000,   -93,
  -249,   323,    99,    78,    72,    -9,   -92, -1000, -1000,   721,
 -1000, -1000, -1000,   765, -1000, -1000, -1000,  -111,   562,  -182,
  -112, -1000,   199,  -113,  -278,  -114, -1000, -1000, -1000,   371,
  -115, -1000,  -116, -1000,  -117,   328,   365,   238, -1000, -1000,
 -1000,   389,   -29,  -118,   -75,    62, -1000,   -61,   168,  -119,
   304,   242,  -184,   186,   256,  -120,    71,   267,   286,   534,
   656,   208,  -174,   -93,   137, -1000, -1000, -1000,   -62,   -93,
 -1000, -1000,  -121,   189,  -122,  -123,  -124,   561,   -29,  -125,
   364,   363,   237,   276,   680, -1000,   362,  -221,   361,   360,
  -126, -1000, -1000, -1000, -1000,   273,   359, -1000,  -127,  -128,
   -10, -1000,   370,   655,   -45, -1000,   236,   654,   244, -1000,
 -1000,  -129,  -130,  -131, -1000,   -93, -1000,   -93, -1000, -1000,
  -132,   -63, -1000,   -93,   188,   730,   111,  -205,  -133,  -134,
  -135, -1000,   729,   179,   126, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000,  -136,  -137,  -138,  -139,  -140, -1000,
  -141,   653,   355, -1000, -1000,  -142,   178,   109, -1000,  -144,
  -303, -1000,  -145,   381,   380, -1000, -1000, -1000,   -11,   -12,
    10, -1000,  -272,  -147,  -148,  -149, -1000, -1000, -1000, -1000,
 -1000,  -150,  -151, -1000, -1000,   -27, -1000, -1000, -1000, -1000,
 -1000,  -182,   635, -1000, -1000, -1000, -1000,   -45, -1000,   354,
  -152,  -153,  -154,  -155, -1000, -1000,   352, -1000, -1000, -1000,
   486,  -156,   560,   175, -1000, -1000, -1000, -1000,   385, -1000,
  -336, -1000,   235, -1000, -1000, -1000, -1000, -1000, -1000,   -17,
   256,  -267, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
   206,   -64,   -65,   -20,   256,   256,   256,   256, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000,   -67,   -68,   294,   293,
   275,   649,   322,   321,   310,   647,   269, -1000, -1000,   725,
 -1000,   657, -1000,   270,   256,   256, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000,   102, -1000, -1000, -1000, -1000, -1000,
   349,   -93,  -157,   233, -1000, -1000, -1000,   -45, -1000,   384,
  -292,   -76,  -158,  -159,  -160,  -161,  -162,  -163,   348,  -165,
  -166, -1000, -1000,  -169,   347, -1000,   106, -1000,  -324,   701,
 -1000, -1000, -1000, -1000,   559, -1000,   -21,   346, -1000,   344,
   343, -1000,   -93, -1000, -1000, -1000,   230,   376,  -171,   229,
 -1000, -1000, -1000, -1000,   155,  -172, -1000, -1000, -1000, -1000,
   -70,   -71,   -74,   -77,   -78,   388,   -22,  -173,   340,   -24,
  -175,   214, -1000,   228, -1000,  -177,  -292,  -178,  -292, -1000,
 -1000,   174,  -180,   167,   164,   160,   159, -1000, -1000, -1000,
 -1000, -1000, -1000,   633, -1000,  -182,   698,  -292, -1000, -1000,
 -1000, -1000,  -189, -1000,   -45, -1000,   -45,   -29,   650,   619,
 -1000,   671,   658,  -190, -1000, -1000, -1000, -1000,   -79,   -80,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,   646,
   645,   643,   -30,   641,   640,   639,   638,   637,   636,   631,
   630,   628,   305,   626, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000,   268, -1000,  -191,   -81, -1000,  -192,   547,   558,
   210, -1000, -1000,   -45, -1000,   105,   103, -1000,   209, -1000,
  -194, -1000, -1000,   331,  -195,  -196, -1000, -1000, -1000,   760,
   555, -1000,  -197,   -32,  -292,    94,  -199,   227,   157,  -200,
  -203,   226,   404, -1000, -1000, -1000, -1000, -1000,  -292, -1000,
 -1000,  -218, -1000, -1000,   -86,  -219,   156,   375,   150,   374,
  -238, -1000,  -240,  -244,  -245,  -247, -1000, -1000, -1000, -1000,
 -1000,   546,   545, -1000,   -33,   -34, -1000,  -336,   -35,   -36,
 -1000,   403, -1000,   -37,   -38,   -40, -1000,   -43,   -46,   -47,
   -48,   -49,   -50,   256,   256,   256, -1000, -1000, -1000, -1000,
   -51, -1000, -1000, -1000, -1000, -1000,   -93,  -256,   544,    60,
    59,  -258, -1000,   551,   -52, -1000, -1000,   -29, -1000,   760,
 -1000,   147, -1000,   -93, -1000,  -259,  -260, -1000,   133,  -263,
  -265,   401,   550, -1000, -1000,  -270,  -271,  -275,  -280, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000,   679,   678, -1000, -1000,
 -1000,   -87, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000,   543,   721, -1000, -1000, -1000,
   225,   224, -1000,   -45,   625,   764,   675, -1000, -1000,   -90,
   -55, -1000,   132, -1000,  -283,   129,   136,  -292,   760, -1000,
   114, -1000,   104,   -56,   -57,   101, -1000,   -93,  -296,  -297,
   542,  -304,   541,   -29,   -29, -1000, -1000,   759,   675, -1000,
 -1000,    87,  -305,   400,  -307,   -88, -1000,   -45,  -315,  -321,
   677,   652,   -89, -1000, -1000, -1000, -1000, -1000, -1000,   675,
 -1000,   540,   -90,   -90,   -58, -1000,  -341,   399, -1000,   539,
 -1000, -1000,   -59,   -91, -1000, -1000,   675, -1000,   330, -1000,
  -347, -1000,   691,   644,   373, -1000, -1000, -1000,  -170,  -361,
   685, -1000, -1000 };
int yypgo[]={

     0,     2,   800,   799,   798,     7,   797,   796,    11,   795,
   792,    10,   791,   790,   789,     9,     6,   788,    12,     5,
   786,   782,   647,   397,     4,   785,   779,    16,     8,     0,
     3,     1 };
int yyr1[]={

     0,    20,    20,    20,    20,    20,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
    21,    21,    21,    21,    21,    21,    21,    21,    21,    11,
    11,     9,     9,     9,    13,    13,    13,    14,    14,    14,
    14,    10,    10,    10,    10,    10,    10,    12,    12,    12,
    22,    22,    27,     1,     2,     2,     2,     2,     2,     2,
     2,     2,     3,     4,     4,    28,    28,    28,    28,    29,
    29,    29,    24,    24,     5,     6,     6,     7,     7,     8,
     8,    25,    25,    15,    15,    16,    26,    26,    30,    30,
    31,    18,    18,    18,    18,    19,    19,    23,    17,    17,
    17 };
int yyr2[]={

     0,     7,     5,     5,     3,     5,     1,     7,    11,     9,
     7,     5,     5,    13,     5,     5,     7,     5,     5,     9,
     7,     7,    11,    11,     7,    23,    23,    27,    15,    13,
    13,     5,     5,     7,    17,     7,    11,     5,     3,     3,
     5,     5,     5,    11,     7,    17,     9,     9,     9,    17,
     7,    19,     7,    11,     5,     9,    11,     5,     5,     7,
     7,     5,     7,     5,    11,    11,     7,     7,    17,    19,
    13,    11,     7,     5,     5,     7,     7,     7,     7,     7,
     9,     9,    25,     7,     7,     7,     7,     7,     7,     7,
     7,     7,    11,    11,    19,     7,     7,     9,     9,     9,
     9,    11,    11,     5,     5,     5,     5,     5,     9,     9,
     9,     9,     7,     5,     5,     5,     9,     9,     9,     9,
     9,     9,     5,     7,     7,     7,     7,     7,    11,     7,
     9,     5,     9,     5,     9,     9,    13,     9,     5,    13,
     5,     5,     7,    19,     7,     9,     9,    11,     9,    17,
    17,    11,    21,     9,     9,    13,    13,    13,    11,    13,
     7,     9,    13,    13,    13,    13,    13,    13,    13,    13,
    13,    11,     9,     9,     9,     7,     5,    11,     7,    11,
     7,     7,     5,     5,     7,    15,    13,    17,    13,    17,
     3,     9,     9,     9,     9,     7,     9,     9,     5,     5,
     5,     5,     5,     9,     7,     5,     5,     7,     7,     7,
    11,     7,     5,     5,     7,     5,     7,     3,     5,    13,
     5,     3,     7,     9,     9,    11,     7,     7,     7,     5,
     5,     5,     5,     5,     5,     7,     5,    11,    11,    17,
     7,     7,     5,     7,    11,     7,     7,     7,     7,     5,
     9,    11,    11,    11,    11,     5,     3,     5,     5,     5,
     5,     5,     7,     7,     5,     5,     5,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     5,     5,     3,     3,     3,     3,
     7,     3,     3,     3,     7,     7,     7,     7,     3,     3,
     3,     3,     3,     7,     3,     2,     2,     2,     0,     2,
     2,     0,     2,     0,     3,     7,     3,     7,     3,     7,
     7,     6,     2,     6,     2,     3,     6,     2,     6,     2,
     3,     3,     3,     3,     3,     3,     3,     1,     3,     3,
     3 };
int yychk[]={

 -1000,   -20,   -21,   287,   256,   257,   261,   262,   403,   309,
   275,   341,   343,   344,   374,    -1,   -18,   355,   280,   288,
   293,   270,   364,   393,   281,   277,   272,   305,   319,   284,
   381,   398,   339,   304,   325,   357,   347,   378,   377,   379,
   326,   286,   285,   283,   356,   282,   289,   337,   336,   354,
   359,   360,   367,   361,   362,   365,   370,   -19,   382,   386,
   369,   296,   313,   259,   278,   295,   303,   334,   260,    -2,
   399,   400,    63,   -21,   287,    10,    10,   259,   263,   123,
   259,   403,   272,   324,   363,   278,   263,   268,   274,   273,
   270,   272,   324,   389,   357,   278,   403,   356,   334,   366,
   358,   264,    47,   269,    61,   342,   403,   299,   272,   389,
   346,   304,   326,   296,   358,   278,   285,   290,   302,   301,
   258,   338,   334,   372,   385,   387,   388,   390,   391,   392,
   403,   403,   268,   403,   395,   279,   272,   266,   340,   269,
   355,    -5,   356,   272,    -6,   403,   355,   270,   306,   274,
   271,    -5,   274,   270,   403,   290,   403,   272,   270,   278,
   356,   403,   276,   399,    40,   324,   272,   399,   272,   399,
   403,   397,   326,   363,   301,   -19,   285,   381,   399,   400,
   397,   400,   285,   272,   403,   -19,   272,   272,   268,   274,
   278,   403,   -19,   403,   403,   309,   350,   349,   348,   394,
   401,   403,   403,   403,   309,   349,   348,   350,   394,   403,
   324,   403,   403,   400,   278,   324,   399,   356,   403,   272,
   271,   403,   326,    -5,    -5,   334,   334,   334,   399,   399,
    37,   -19,   403,   272,   368,   373,   285,   290,   274,   341,
   343,   353,   353,   399,   401,   -28,    44,    59,    10,    10,
   403,   123,   -22,   -27,   403,   403,   400,    40,   403,   403,
   309,   349,   348,   350,   403,   270,   403,   403,   403,   273,
   271,   324,   265,   -18,   403,   399,   400,    63,   403,   399,
   123,   403,   356,   400,   -17,   324,   262,   357,   403,   284,
   284,   334,   375,   376,   380,   378,   301,   372,   377,   379,
   400,   326,   296,   333,   309,   350,   349,   348,   -11,   311,
   312,   403,   -13,   351,   352,   355,   291,   297,   274,   306,
   299,   323,   314,   320,   288,   315,   293,   -10,   310,   318,
    37,   302,   322,    61,   325,   335,   -14,   401,   265,   278,
   338,   290,   275,   -19,   372,   309,   383,   384,   375,   376,
   400,   -19,   403,   340,   403,   403,   403,   123,   -18,   403,
   271,   271,   324,   324,   271,    44,   271,   271,   403,   271,
   271,   403,   301,   271,   403,   403,   399,   270,    61,    -1,
   403,    63,   399,   400,   -23,   324,    61,   321,   403,   403,
   403,   -19,   -19,   403,   400,   -19,   340,    37,   342,   266,
   403,   403,   403,   403,    37,   340,   309,   349,   348,   350,
   403,   403,   403,   403,   403,   403,    61,   271,   403,   340,
   342,   403,   403,   356,   403,   269,   258,   269,   258,   399,
   399,   385,   340,   403,   403,   403,   403,   403,   403,   403,
   399,   400,    63,   -22,   125,    44,    -1,   271,   403,   403,
   403,   403,   271,   273,   123,   403,   123,   340,   267,    -7,
    -8,   403,   399,   324,   399,   -11,   -11,   403,   340,   258,
   400,   400,   399,   -11,   -11,   -11,   -11,   400,   400,   292,
   292,   300,    61,   270,   274,   306,   270,   274,   306,   270,
   274,   306,    61,   301,    37,    37,    -9,   307,   302,   308,
   -11,   -11,   380,   301,   271,   -19,   403,   324,    -1,   267,
    -5,   403,   273,   123,   403,   403,   403,   403,   403,   403,
   271,   403,   403,   403,   271,   342,   403,   399,    41,   123,
   -23,   399,   271,   271,   271,   -19,   324,   269,   403,   324,
   269,   356,   403,   400,   400,   400,   400,   400,   265,   399,
   403,   271,   399,   403,   330,   324,   403,    -5,   403,    -5,
   340,   403,   340,   340,   340,   340,   125,   -27,    41,    -5,
   403,    -1,    -1,   -18,    91,    40,   125,    44,    47,    47,
   403,   400,   400,    61,    61,    61,   399,    61,    61,    61,
    61,    61,    61,    61,    61,    61,   -12,   258,   317,   316,
    61,   301,   403,   400,   403,   125,   123,   330,    -1,   342,
   342,   330,   403,   267,   272,   403,   403,   -24,    10,   123,
   403,   399,    -5,   345,   403,   324,   340,   403,   403,   324,
   258,    -5,   403,   400,   403,   340,   269,   340,   269,   403,
   403,   403,   403,   403,   125,   125,   399,   399,    -8,   399,
   399,   258,   399,   399,   399,   399,   399,   399,   399,   399,
   399,   -11,   -11,   -11,   399,    -3,    -4,   -19,   403,   125,
   356,   356,   403,   123,   399,   -25,   -15,   -16,   -18,   -24,
   340,   -19,   403,   403,   340,   403,   403,   258,   123,   403,
   403,   403,   403,    44,    44,   400,   125,   -28,   324,   324,
    -1,    61,   -24,    10,   -29,    44,    59,   -26,   -30,   -31,
   400,   399,   340,   403,   340,   330,    -5,   -24,   340,   340,
   399,   399,   340,   -19,   403,   403,   125,   403,   125,   -15,
   -16,   -24,    10,   -29,   345,   403,   258,   403,   400,    -1,
   403,   403,    44,    44,   400,   125,   -30,   -31,   399,   403,
   258,   125,   399,   399,   272,   403,    41,    93,    44,   269,
   399,   403,    41 };
int yydef[]={

    -2,    -2,     0,     4,     0,     0,     0,    38,    -2,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,    39,     0,     0,   256,     0,     0,     0,     0,
   217,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   190,     0,     0,     0,     0,     0,     0,   221,     0,
     0,     0,     0,     0,     0,     0,     0,   267,   268,    -2,
    -2,    -2,    -2,     0,     3,     2,     5,     0,     0,     0,
     0,    11,    54,     0,     0,     0,    12,    14,    31,     0,
    37,    40,    63,    73,     0,   122,     0,   201,   199,   200,
   202,     0,     0,     0,     0,     0,    15,     0,     0,   231,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   229,   230,   233,   234,   236,
    17,    18,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   133,     0,     0,   314,   316,     0,     0,     0,     0,
     0,   176,    32,    42,   138,     0,     0,    41,     0,     0,
     0,   255,     0,     0,     0,   337,     0,     0,     0,    57,
    58,     0,     0,     0,   212,   213,   215,     0,   335,   336,
     0,   218,   220,    61,     0,     0,     0,     0,     0,     0,
     0,   249,     0,     0,    74,   103,   104,   105,   106,   107,
   266,   113,   114,   115,     0,     0,     0,     0,     0,   182,
     0,     0,   131,   141,   140,     0,     0,     0,   242,     0,
     0,   183,     0,     0,     0,   198,   205,   206,     0,     0,
     0,   232,     0,     0,     0,     0,   257,   258,   259,   260,
   261,     0,     0,   264,   265,     0,   305,   306,   307,     1,
     7,     0,     0,   291,   292,    10,    52,     0,    66,    96,
     0,     0,     0,     0,   124,    35,     0,    67,    79,   123,
     0,   144,     0,     0,   331,   332,   333,   334,     0,   127,
     0,   129,     0,    16,    33,   338,   339,   340,    50,     0,
     0,     0,    83,    84,    85,    86,    87,    88,    89,    90,
    91,     0,     0,     0,     0,     0,     0,     0,   112,   269,
   270,   125,   142,   274,   275,   276,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   160,   281,   282,
   283,     0,   286,     0,     0,     0,   195,   204,   209,   277,
   278,   279,   280,   211,   222,   226,   227,   228,   240,   241,
   235,     0,     0,     0,    20,    21,    72,     0,    24,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   175,   180,     0,     0,   126,     0,    44,     0,     0,
   298,   299,   300,   301,     0,   337,     0,     0,    59,   181,
    95,   214,     0,    60,   216,    62,     0,     0,     0,     0,
   247,   245,   246,   248,     0,     0,    75,    76,    77,    78,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   243,   178,     0,   184,     0,     0,     0,     0,   207,
   208,     0,     0,     0,     0,     0,     0,   262,   263,   294,
   295,   296,   297,     0,     9,     0,     0,     0,    97,    98,
    99,   100,     0,   137,     0,   145,     0,     0,     0,     0,
   318,     0,     0,     0,    80,    81,   196,   197,     0,     0,
   121,   193,   194,   108,   109,   110,   111,   153,   154,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   284,   285,   161,   271,   272,   273,
   191,   192,   223,   224,     0,     0,    19,     0,     0,     0,
     0,   134,   135,     0,   146,     0,     0,   315,     0,   172,
     0,   173,   174,     0,     0,     0,    46,    47,    48,   313,
     0,    55,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   116,   117,   118,   119,   120,     0,   130,
   132,     0,   203,   148,     0,     0,     0,     0,     0,     0,
     0,   250,     0,     0,     0,     0,     8,   290,    53,   102,
    36,     0,     0,    23,     0,     0,   128,     0,     0,     0,
   151,    92,    93,     0,     0,     0,   158,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   171,   287,   288,   289,
     0,   225,   238,   237,    71,    22,     0,     0,     0,     0,
     0,     0,   177,     0,     0,    43,   147,     0,   312,   313,
    56,     0,   101,     0,    64,     0,     0,    65,     0,     0,
     0,     0,     0,   244,   179,     0,     0,     0,     0,   210,
   251,   252,   253,   254,   139,    13,     0,     0,   317,   319,
   320,     0,   155,   156,   157,   162,   163,   164,   165,   166,
   167,   168,   169,   170,   159,     0,    -2,   304,    29,   136,
     0,     0,    30,     0,     0,   313,    -2,   324,   325,     0,
     0,   219,     0,    70,     0,     0,     0,     0,   313,   186,
     0,   188,     0,     0,     0,     0,    28,     0,     0,     0,
     0,     0,     0,   312,     0,   309,   310,   313,    -2,   329,
   330,     0,     0,     0,     0,     0,   185,     0,     0,     0,
     0,     0,     0,   303,   149,   150,    34,    45,    49,    -2,
   323,     0,   312,     0,     0,    68,     0,     0,   239,     0,
   187,   189,     0,     0,    94,    51,    -2,   328,     0,    69,
     0,   143,     0,     0,     0,   152,    25,    26,     0,     0,
     0,    82,    27 };
typedef struct { char *t_name; int t_val; } yytoktype;
#ifndef YYDEBUG
#	define YYDEBUG	0	/* don't allow debugging */
#endif

#if YYDEBUG

yytoktype yytoks[] =
{
	"ADD",	257,
	"AND",	258,
	"VAR",	259,
	"QUIT",	260,
	"DEL",	261,
	"LIST",	262,
	"VARS",	263,
	"DEPENDS",	264,
	"ON",	265,
	"IN",	266,
	"IS",	267,
	"STRUCTURE",	268,
	"OF",	269,
	"FAM",	270,
	"FOR",	271,
	"RULE",	272,
	"ALL",	273,
	"DESCRIPTIONS",	274,
	"SET",	275,
	"CURRENT",	276,
	"SHOW",	277,
	"OPT",	278,
	"NODE",	279,
	"DERIVE",	280,
	"SEL",	281,
	"LOAD",	282,
	"UNDEF",	283,
	"TEST",	284,
	"EVALUATE",	285,
	"EXPECT",	286,
	"COMMENT",	287,
	"LEARN",	288,
	"STAT",	289,
	"GA",	290,
	"POPULATION",	291,
	"POINTS",	292,
	"PLOT",	293,
	"MAN",	294,
	"WAIT",	295,
	"DEBUG",	296,
	"ITERATIONS",	297,
	"LEX",	298,
	"PRINT",	299,
	"FREQ",	300,
	"ERROR",	301,
	"MAX",	302,
	"YECHO",	303,
	"SAVE",	304,
	"IMP",	305,
	"WEIGHT",	306,
	"MIN",	307,
	"MULT",	308,
	"INFORMATIVITY",	309,
	"GAABS",	310,
	"YES",	311,
	"NO",	312,
	"PREFER",	313,
	"MUTATION",	314,
	"POLICY",	315,
	"CUSTOM",	316,
	"OR",	317,
	"LSQR",	318,
	"RESET",	319,
	"CROSSOVER",	320,
	"USAGE",	321,
	"NORM",	322,
	"WIDTH",	323,
	"TABLE",	324,
	"SPLIT",	325,
	"DECOMPOSE",	326,
	"REDO",	327,
	"GAMMA",	328,
	"TS",	329,
	"USING",	330,
	"CL",	331,
	"SIGM",	332,
	"KNN",	333,
	"COLOR",	334,
	"COMPUTE",	335,
	"ONE",	336,
	"COMPOSE",	337,
	"HEURISTIC",	338,
	"COPY",	339,
	"TO",	340,
	"QUALITATIVE",	341,
	"FROM",	342,
	"QUANTITATIVE",	343,
	"COMPARE",	344,
	"STEP",	345,
	"REPEAT",	346,
	"YLOG",	347,
	"GR",	348,
	"GINI",	349,
	"RELIEFF",	350,
	"FUZZY",	351,
	"CRISP",	352,
	"PREFIX",	353,
	"JOIN",	354,
	"INTERVAL",	355,
	"INSTANCE",	356,
	"TREE",	357,
	"DM",	358,
	"PJOIN",	359,
	"FJOIN",	360,
	"SURE",	361,
	"NEED",	362,
	"REDUNDANT",	363,
	"VECT",	364,
	"SAME",	365,
	"GROUP",	366,
	"ANALYZE",	367,
	"NAMES",	368,
	"WRITE",	369,
	"DIFFERENT",	370,
	"SOFT",	371,
	"MNUMBER",	372,
	"DOT",	373,
	"COUNT",	374,
	"LOCAL",	375,
	"GLOBAL",	376,
	"SDTIC",	377,
	"DFC",	378,
	"DTIC",	379,
	"CM",	380,
	"MERGE",	381,
	"PAIRS",	382,
	"LAPLACE",	383,
	"CLUSTER",	384,
	"NOISE",	385,
	"SEED",	386,
	"DONTCARE",	387,
	"DONTKNOW",	388,
	"APRIORY",	389,
	"DISTRIBUTION",	390,
	"CV",	391,
	"SAMPLE",	392,
	"SORT",	393,
	"MDL",	394,
	"LEAF",	395,
	"NOD",	396,
	"DUPLICATE",	397,
	"EXPAND",	398,
	"NUM",	399,
	"INUM",	400,
	"STRING",	401,
	"FNAME",	402,
	"ID",	403,
	"-unknown-",	-1	/* ends search */
};

char * yyreds[] =
{
	"-no such reduction-",
	"commands : commands command '\n'",
	"commands : command '\n'",
	"commands : commands COMMENT",
	"commands : COMMENT",
	"commands : error '\n'",
	"command : /* empty */",
	"command : ADD VAR ID",
	"command : DEL VARS '{' new_vars '}'",
	"command : DEL '{' new_vars '}'",
	"command : DEL VAR ID",
	"command : DEL ID",
	"command : LIST VARS",
	"command : ID DEPENDS ON '{' str_list '}'",
	"command : LIST STRUCTURE",
	"command : INFORMATIVITY ID",
	"command : SET PRINT INUM",
	"command : QUALITATIVE ID",
	"command : QUANTITATIVE ID",
	"command : COMPARE STRUCTURE ID ID",
	"command : COUNT LEAF ID",
	"command : COUNT NODE ID",
	"command : str_list IN '{' str_list '}'",
	"command : ID '/' id_num TO id_num",
	"command : id_num TO id_num",
	"command : ID OF ID IS '[' NUM ',' NUM ',' NUM ')'",
	"command : ID OF ID IS '(' NUM ',' NUM ',' NUM ']'",
	"command : ID OF ID IS '(' NUM ',' NUM ',' NUM ',' NUM ')'",
	"command : INTERVAL OF ID IS '{' num_list '}'",
	"command : DERIVE INTERVAL FOR var_list USING ID",
	"command : LEARN INTERVAL FOR ID USING ID",
	"command : LIST DESCRIPTIONS",
	"command : PLOT DESCRIPTIONS",
	"command : SET RULE encode_rules_type",
	"command : FAM ID FOR ID IS '{' str_list '}'",
	"command : LIST ALL FAM",
	"command : LIST FAM ID FOR ID",
	"command : LIST FAM",
	"command : LIST",
	"command : VECT",
	"command : LIST RULE",
	"command : SORT RULE",
	"command : PLOT FAM",
	"command : SEL FAM ID FOR ID",
	"command : SHOW CURRENT FAM",
	"command : FAM ID FOR ID RULE NUM '=' ID",
	"command : RULE NUM '=' ID",
	"command : RULE NUM '=' NUM",
	"command : RULE '(' str_list ')'",
	"command : RULE TABLE prepare_rt '{' poss_nl rule_table poss_nl '}'",
	"command : SET APRIORY ID",
	"command : RULE RULE TABLE prepare_rt '{' poss_nl i_rule_table poss_nl '}'",
	"command : DEL RULE INUM",
	"command : DEL RULE '(' str_list ')'",
	"command : DEL RULE",
	"command : IMP NUM '=' NUM",
	"command : RESET RULE USAGE FOR ID",
	"command : RESET NUM",
	"command : RESET ID",
	"command : TEST DUPLICATE ID",
	"command : MERGE DUPLICATE ID",
	"command : EXPAND RULE",
	"command : EXPAND RULE num",
	"command : LIST TABLE",
	"command : COPY ID TO TABLE ID",
	"command : SAVE RULE IN TABLE ID",
	"command : DEL TABLE ID",
	"command : LIST TABLE ID",
	"command : COPY num '%' OF TABLE ID TO ID",
	"command : SPLIT num '%' OF ID TO ID AND ID",
	"command : COPY RULE FROM ID TO ID",
	"command : COMPARE ID TO TABLE ID",
	"command : COUNT RULE ID",
	"command : LIST APRIORY",
	"command : TREE ID",
	"command : TREE ID INFORMATIVITY",
	"command : TREE ID GINI",
	"command : TREE ID GR",
	"command : TREE ID RELIEFF",
	"command : LIST TREE ID",
	"command : SET REPEAT TEST NUM",
	"command : SET SAVE TEST yesno",
	"command : TEST DECOMPOSE ID FOR NUM TO NUM STEP NUM RULE OF ID",
	"command : SET DECOMPOSE LOCAL",
	"command : SET DECOMPOSE GLOBAL",
	"command : SET DECOMPOSE CM",
	"command : SET DECOMPOSE DFC",
	"command : SET DECOMPOSE ERROR",
	"command : SET DECOMPOSE MNUMBER",
	"command : SET DECOMPOSE SDTIC",
	"command : SET DECOMPOSE DTIC",
	"command : SET DECOMPOSE INUM",
	"command : SET DECOMPOSE INUM TO INUM",
	"command : SET DECOMPOSE INUM AND INUM",
	"command : SET DECOMPOSE INUM TO INUM AND INUM TO INUM",
	"command : TEST REDUNDANT ID",
	"command : DEL REDUNDANT ID",
	"command : DEL REDUNDANT INFORMATIVITY ID",
	"command : DEL REDUNDANT GINI ID",
	"command : DEL REDUNDANT GR ID",
	"command : DEL REDUNDANT RELIEFF ID",
	"command : TEST REDUNDANT ID FOR var_list",
	"command : DEL REDUNDANT ID FOR var_list",
	"command : YLOG INFORMATIVITY",
	"command : YLOG RELIEFF",
	"command : YLOG GINI",
	"command : YLOG GR",
	"command : YLOG MDL",
	"command : SET DEBUG INFORMATIVITY yesno",
	"command : SET DEBUG RELIEFF yesno",
	"command : SET DEBUG GINI yesno",
	"command : SET DEBUG GR yesno",
	"command : SET DM yesno",
	"command : DFC ID",
	"command : SDTIC ID",
	"command : DTIC ID",
	"command : DECOMPOSE INFORMATIVITY ID INUM",
	"command : DECOMPOSE GINI ID INUM",
	"command : DECOMPOSE GR ID INUM",
	"command : DECOMPOSE RELIEFF ID INUM",
	"command : DECOMPOSE MDL ID INUM",
	"command : SET DECOMPOSE DECOMPOSE INUM",
	"command : LIST OPT",
	"command : LIST OPT ALL",
	"command : DEL OPT ID",
	"command : SET OPT ID",
	"command : SEL OPT ID",
	"command : ID '=' NUM",
	"command : ID '=' '{' q_list '}'",
	"command : ID '=' ID",
	"command : EXPECT ID '=' NUM",
	"command : EVALUATE ID",
	"command : EVALUATE ID FOR ID",
	"command : DERIVE var_list",
	"command : DERIVE var_list FOR ID",
	"command : DERIVE var_list FOR ALL",
	"command : DERIVE var_list FOR '{' str_list '}'",
	"command : LIST ID FOR ALL",
	"command : PLOT ID",
	"command : LIST ID FOR '{' str_list '}'",
	"command : UNDEF OPT",
	"command : EVALUATE INUM",
	"command : SET EVALUATE eval_type",
	"command : INSTANCE TABLE ID FOR ID '{' poss_nl str_list '}'",
	"command : LIST INSTANCE TABLE",
	"command : LIST INSTANCE TABLE ID",
	"command : DERIVE INSTANCE TABLE ID",
	"command : SEL INSTANCE NUM FROM ID",
	"command : LOAD INSTANCE FROM ID",
	"command : DERIVE RULE TABLE ID FROM INSTANCE TABLE ID",
	"command : DERIVE RULE FOR ID FROM INSTANCE TABLE ID",
	"command : ID FROM INSTANCE TABLE ID",
	"command : SPLIT num '%' INSTANCE TABLE ID TO ID AND ID",
	"command : SET GA POPULATION INUM",
	"command : SET GA ITERATIONS INUM",
	"command : SET GA DESCRIPTIONS POINTS '=' NUM",
	"command : SET GA WEIGHT POINTS '=' NUM",
	"command : SET GA PRINT FREQ '=' NUM",
	"command : SET GA WIDTH '=' NUM",
	"command : SET MAX PLOT ERROR '=' NUM",
	"command : SET ERROR ga_error_entry",
	"command : SET AND '=' fand",
	"command : SET GA MUTATION FAM '=' NUM",
	"command : SET GA MUTATION DESCRIPTIONS '=' NUM",
	"command : SET GA MUTATION WEIGHT '=' NUM",
	"command : SET GA CROSSOVER FAM '=' NUM",
	"command : SET GA CROSSOVER DESCRIPTIONS '=' NUM",
	"command : SET GA CROSSOVER WEIGHT '=' NUM",
	"command : SET GA LEARN FAM '=' yesno",
	"command : SET GA LEARN DESCRIPTIONS '=' yesno",
	"command : SET GA LEARN WEIGHT '=' yesno",
	"command : SET GA POLICY '=' ga_policy_entry",
	"command : LEARN FAM FOR ID",
	"command : LEARN WEIGHT FOR ID",
	"command : LEARN DESCRIPTIONS FOR ID",
	"command : LEARN FOR ID",
	"command : LEARN var_list",
	"command : LEARN FAM ID FOR ID",
	"command : STAT FOR ID",
	"command : STAT FOR INSTANCE TABLE ID",
	"command : PLOT GA ERROR",
	"command : TEST DECOMPOSE ID",
	"command : DECOMPOSE ID",
	"command : COMPOSE ID",
	"command : ONE DECOMPOSE ID",
	"command : DECOMPOSE TABLE ID ON var_list AND var_list",
	"command : JOIN var_list OF ID TO ID",
	"command : JOIN var_list AND var_list OF ID TO ID",
	"command : PJOIN var_list OF ID TO ID",
	"command : PJOIN var_list AND var_list OF ID TO ID",
	"command : FJOIN",
	"command : SET HEURISTIC SPLIT yesno",
	"command : SET HEURISTIC COMPUTE yesno",
	"command : SET DECOMPOSE DEBUG INUM",
	"command : SET DECOMPOSE KNN NUM",
	"command : SET COLOR coloring_entry",
	"command : SET SAVE COLOR yesno",
	"command : SET SAVE COLOR ID",
	"command : ANALYZE COLOR",
	"command : LIST COLOR",
	"command : LIST GROUP",
	"command : LIST INSTANCE",
	"command : LIST DM",
	"command : INSTANCE NUM TO NUM",
	"command : SET COLOR STRING",
	"command : SURE COLOR",
	"command : NEED COLOR",
	"command : SAME NUM NUM",
	"command : DIFFERENT NUM NUM",
	"command : SET COLOR ON",
	"command : num '%' NOISE TO ID",
	"command : SET MNUMBER num",
	"command : TEST ERROR",
	"command : TEST num",
	"command : TEST num num",
	"command : TEST EVALUATE",
	"command : MERGE INUM INUM",
	"command : MERGE",
	"command : MERGE INUM",
	"command : TEST MERGE num num STEP num",
	"command : MERGE EVALUATE",
	"command : PAIRS",
	"command : SET NOISE MNUMBER",
	"command : SET NOISE MNUMBER CM",
	"command : SET NOISE MNUMBER ERROR",
	"command : SET NOISE MNUMBER CM ERROR",
	"command : SET NOISE INFORMATIVITY",
	"command : SET NOISE LAPLACE",
	"command : SET NOISE CLUSTER",
	"command : SET DONTCARE",
	"command : SET DONTKNOW",
	"command : SET APRIORY",
	"command : SEED num",
	"command : SET DISTRIBUTION",
	"command : SET CV",
	"command : SET CV INUM",
	"command : SET SAMPLE",
	"command : SET SAMPLE num num INUM",
	"command : SET CV INUM FOR ID",
	"command : SPLIT ID TO ID AND ID USING INUM",
	"command : SET NOISE LOCAL",
	"command : SET NOISE GLOBAL",
	"command : LOAD ID",
	"command : LOAD RULE ID",
	"command : LOAD RULE ID USING INUM",
	"command : SAVE STRUCTURE ID",
	"command : SAVE DESCRIPTIONS ID",
	"command : SAVE RULE ID",
	"command : SAVE OPT ID",
	"command : SAVE ID",
	"command : WRITE ID TO ID",
	"command : WRITE ID ID TO ID",
	"command : WRITE RULE ID TO ID",
	"command : WRITE NAMES ID TO ID",
	"command : WRITE DOT ID TO ID",
	"command : SEL ID",
	"command : SHOW",
	"command : DEBUG EVALUATE",
	"command : DEBUG GA",
	"command : DEBUG DESCRIPTIONS",
	"command : PREFER QUALITATIVE",
	"command : PREFER QUANTITATIVE",
	"command : VAR PREFIX ID",
	"command : OPT PREFIX ID",
	"command : WAIT NUM",
	"command : YECHO STRING",
	"command : YLOG STRING",
	"command : COLOR",
	"command : QUIT",
	"yesno : YES",
	"yesno : NO",
	"fand : MIN",
	"fand : MAX",
	"fand : MULT",
	"eval_type : FUZZY",
	"eval_type : CRISP",
	"eval_type : INTERVAL",
	"coloring_entry : OPT",
	"coloring_entry : HEURISTIC",
	"coloring_entry : GA",
	"coloring_entry : SET",
	"ga_error_entry : GAABS",
	"ga_error_entry : LSQR",
	"ga_error_entry : '%'",
	"ga_error_entry : LSQR '%'",
	"ga_error_entry : MAX '%'",
	"ga_error_entry : NORM",
	"ga_policy_entry : AND",
	"ga_policy_entry : OR",
	"ga_policy_entry : CUSTOM",
	"new_vars : new_vars ',' new_var",
	"new_vars : new_var",
	"new_var : ID",
	"str_list : str_list_rev",
	"str_list_rev : str_list_rev separator_nl ID",
	"str_list_rev : str_list_rev separator_nl NUM",
	"str_list_rev : str_list_rev separator_nl INUM",
	"str_list_rev : str_list_rev separator_nl '?'",
	"str_list_rev : ID",
	"str_list_rev : '?'",
	"str_list_rev : NUM",
	"str_list_rev : INUM",
	"num_list : num_list_rev",
	"num_list_rev : num_list_rev separator_nl num",
	"num_list_rev : num",
	"separator_nl : ','",
	"separator_nl : ';'",
	"separator_nl : '\n'",
	"separator_nl : /* empty */",
	"separator : ','",
	"separator : ';'",
	"separator : /* empty */",
	"poss_nl : '\n'",
	"poss_nl : /* empty */",
	"var_list : var_list_rev",
	"var_list_rev : var_list_rev ',' ID",
	"var_list_rev : ID",
	"q_list : q_list ',' q_list_el",
	"q_list : q_list_el",
	"q_list_el : ID '/' NUM",
	"q_list_el : NUM '/' NUM",
	"rule_table : rule_table '\n' att_entry",
	"rule_table : att_entry",
	"att_entry : att_entry separator att_id",
	"att_entry : att_id",
	"att_id : id_num",
	"i_rule_table : i_rule_table '\n' i_att_entry",
	"i_rule_table : i_att_entry",
	"i_att_entry : i_att_entry separator i_att_id",
	"i_att_entry : i_att_id",
	"i_att_id : INUM",
	"id_num : ID",
	"id_num : NUM",
	"id_num : INUM",
	"id_num : '?'",
	"num : NUM",
	"num : INUM",
	"prepare_rt : /* empty */",
	"encode_rules_type : TABLE",
	"encode_rules_type : LIST",
	"encode_rules_type : TREE",
};
#endif /* YYDEBUG */
#line 1 "/usr/lib/yaccpar"
/*	@(#)yaccpar 1.10 89/04/04 SMI; from S5R3 1.10	*/

/*
** Skeleton parser driver for yacc output
*/

/*
** yacc user known macros and defines
*/
#define YYERROR		goto yyerrlab
#define YYACCEPT	{ free(yys); free(yyv); return(0); }
#define YYABORT		{ free(yys); free(yyv); return(1); }
#define YYBACKUP( newtoken, newvalue )\
{\
	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
	{\
		yyerror( "syntax error - cannot backup" );\
		goto yyerrlab;\
	}\
	yychar = newtoken;\
	yystate = *yyps;\
	yylval = newvalue;\
	goto yynewstate;\
}
#define YYRECOVERING()	(!!yyerrflag)
#ifndef YYDEBUG
#	define YYDEBUG	1	/* make debugging available */
#endif

/*
** user known globals
*/
int yydebug;			/* set to 1 to get debugging */

/*
** driver internal defines
*/
#define YYFLAG		(-1000)

/*
** static variables used by the parser
*/
static YYSTYPE *yyv;			/* value stack */
static int *yys;			/* state stack */

static YYSTYPE *yypv;			/* top of value stack */
static int *yyps;			/* top of state stack */

static int yystate;			/* current state */
static int yytmp;			/* extra var (lasts between blocks) */

int yynerrs;			/* number of errors */

int yyerrflag;			/* error recovery flag */
int yychar;			/* current input token number */


/*
** yyparse - return 0 if worked, 1 if syntax error not recovered from
*/
int
yyparse()
{
	register YYSTYPE *yypvt;	/* top of value stack for $vars */
	unsigned yymaxdepth = YYMAXDEPTH;

	/*
	** Initialize externals - yyparse may be called more than once
	*/
	yyv = (YYSTYPE*)malloc(yymaxdepth*sizeof(YYSTYPE));
	yys = (int*)malloc(yymaxdepth*sizeof(int));
	if (!yyv || !yys)
	{
		yyerror( "out of memory" );
		return(1);
	}
	yypv = &yyv[-1];
	yyps = &yys[-1];
	yystate = 0;
	yytmp = 0;
	yynerrs = 0;
	yyerrflag = 0;
	yychar = -1;

	goto yystack;
	{
		register YYSTYPE *yy_pv;	/* top of value stack */
		register int *yy_ps;		/* top of state stack */
		register int yy_state;		/* current state */
		register int  yy_n;		/* internal state number info */

		/*
		** get globals into registers.
		** branch to here only if YYBACKUP was called.
		*/
	yynewstate:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;
		goto yy_newstate;

		/*
		** get globals into registers.
		** either we just started, or we just finished a reduction
		*/
	yystack:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;

		/*
		** top of for (;;) loop while no reductions done
		*/
	yy_stack:
		/*
		** put a state and value onto the stacks
		*/
#if YYDEBUG
		/*
		** if debugging, look up token value in list of value vs.
		** name pairs.  0 and negative (-1) are special values.
		** Note: linear search is used since time is not a real
		** consideration while debugging.
		*/
		if ( yydebug )
		{
			register int yy_i;

			(void)printf( "State %d, token ", yy_state );
			if ( yychar == 0 )
				(void)printf( "end-of-file\n" );
			else if ( yychar < 0 )
				(void)printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				(void)printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
		{
			/*
			** reallocate and recover.  Note that pointers
			** have to be reset, or bad things will happen
			*/
			int yyps_index = (yy_ps - yys);
			int yypv_index = (yy_pv - yyv);
			int yypvt_index = (yypvt - yyv);
			yymaxdepth += YYMAXDEPTH;
			yyv = (YYSTYPE*)realloc((char*)yyv,
				yymaxdepth * sizeof(YYSTYPE));
			yys = (int*)realloc((char*)yys,
				yymaxdepth * sizeof(int));
			if (!yyv || !yys)
			{
				yyerror( "yacc stack overflow" );
				return(1);
			}
			yy_ps = yys + yyps_index;
			yy_pv = yyv + yypv_index;
			yypvt = yyv + yypvt_index;
		}
		*yy_ps = yy_state;
		*++yy_pv = yyval;

		/*
		** we have a new state - find out what to do
		*/
	yy_newstate:
		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
			goto yydefault;		/* simple state */
#if YYDEBUG
		/*
		** if debugging, need to mark whether new token grabbed
		*/
		yytmp = yychar < 0;
#endif
		if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
			yychar = 0;		/* reached EOF */
#if YYDEBUG
		if ( yydebug && yytmp )
		{
			register int yy_i;

			(void)printf( "Received token " );
			if ( yychar == 0 )
				(void)printf( "end-of-file\n" );
			else if ( yychar < 0 )
				(void)printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				(void)printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
			goto yydefault;
		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
		{
			yychar = -1;
			yyval = yylval;
			yy_state = yy_n;
			if ( yyerrflag > 0 )
				yyerrflag--;
			goto yy_stack;
		}

	yydefault:
		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
		{
#if YYDEBUG
			yytmp = yychar < 0;
#endif
			if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
				yychar = 0;		/* reached EOF */
#if YYDEBUG
			if ( yydebug && yytmp )
			{
				register int yy_i;

				(void)printf( "Received token " );
				if ( yychar == 0 )
					(void)printf( "end-of-file\n" );
				else if ( yychar < 0 )
					(void)printf( "-none-\n" );
				else
				{
					for ( yy_i = 0;
						yytoks[yy_i].t_val >= 0;
						yy_i++ )
					{
						if ( yytoks[yy_i].t_val
							== yychar )
						{
							break;
						}
					}
					(void)printf( "%s\n", yytoks[yy_i].t_name );
				}
			}
#endif /* YYDEBUG */
			/*
			** look through exception table
			*/
			{
				register int *yyxi = yyexca;

				while ( ( *yyxi != -1 ) ||
					( yyxi[1] != yy_state ) )
				{
					yyxi += 2;
				}
				while ( ( *(yyxi += 2) >= 0 ) &&
					( *yyxi != yychar ) )
					;
				if ( ( yy_n = yyxi[1] ) < 0 )
					YYACCEPT;
			}
		}

		/*
		** check for syntax error
		*/
		if ( yy_n == 0 )	/* have an error */
		{
			/* no worry about speed here! */
			switch ( yyerrflag )
			{
			case 0:		/* new error */
				yyerror( "syntax error" );
				goto skip_init;
			yyerrlab:
				/*
				** get globals into registers.
				** we have a user generated syntax type error
				*/
				yy_pv = yypv;
				yy_ps = yyps;
				yy_state = yystate;
				yynerrs++;
			skip_init:
			case 1:
			case 2:		/* incompletely recovered error */
					/* try again... */
				yyerrflag = 3;
				/*
				** find state where "error" is a legal
				** shift action
				*/
				while ( yy_ps >= yys )
				{
					yy_n = yypact[ *yy_ps ] + YYERRCODE;
					if ( yy_n >= 0 && yy_n < YYLAST &&
						yychk[yyact[yy_n]] == YYERRCODE)					{
						/*
						** simulate shift of "error"
						*/
						yy_state = yyact[ yy_n ];
						goto yy_stack;
					}
					/*
					** current state has no shift on
					** "error", pop stack
					*/
#if YYDEBUG
#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
					if ( yydebug )
						(void)printf( _POP_, *yy_ps,
							yy_ps[-1] );
#	undef _POP_
#endif
					yy_ps--;
					yy_pv--;
				}
				/*
				** there is no state on stack with "error" as
				** a valid shift.  give up.
				*/
				YYABORT;
			case 3:		/* no shift yet; eat a token */
#if YYDEBUG
				/*
				** if debugging, look up token in list of
				** pairs.  0 and negative shouldn't occur,
				** but since timing doesn't matter when
				** debugging, it doesn't hurt to leave the
				** tests here.
				*/
				if ( yydebug )
				{
					register int yy_i;

					(void)printf( "Error recovery discards " );
					if ( yychar == 0 )
						(void)printf( "token end-of-file\n" );
					else if ( yychar < 0 )
						(void)printf( "token -none-\n" );
					else
					{
						for ( yy_i = 0;
							yytoks[yy_i].t_val >= 0;
							yy_i++ )
						{
							if ( yytoks[yy_i].t_val
								== yychar )
							{
								break;
							}
						}
						(void)printf( "token %s\n",
							yytoks[yy_i].t_name );
					}
				}
#endif /* YYDEBUG */
				if ( yychar == 0 )	/* reached EOF. quit */
					YYABORT;
				yychar = -1;
				goto yy_newstate;
			}
		}/* end if ( yy_n == 0 ) */
		/*
		** reduction by production yy_n
		** put stack tops, etc. so things right after switch
		*/
#if YYDEBUG
		/*
		** if debugging, print the string that is the user's
		** specification of the reduction which is just about
		** to be done.
		*/
		if ( yydebug )
			(void)printf( "Reduce by (%d) \"%s\"\n",
				yy_n, yyreds[ yy_n ] );
#endif
		yytmp = yy_n;			/* value to switch over */
		yypvt = yy_pv;			/* $vars top of value stack */
		/*
		** Look in goto table for next state
		** Sorry about using yy_state here as temporary
		** register variable, but why not, if it works...
		** If yyr2[ yy_n ] doesn't have the low order bit
		** set, then there is no action to be done for
		** this reduction.  So, no saving & unsaving of
		** registers done.  The only difference between the
		** code just after the if and the body of the if is
		** the goto yy_stack in the body.  This way the test
		** can be made before the choice of what to do is needed.
		*/
		{
			/* length of production doubled with extra bit */
			register int yy_len = yyr2[ yy_n ];

			if ( !( yy_len & 01 ) )
			{
				yy_len >>= 1;
				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
					*( yy_ps -= yy_len ) + 1;
				if ( yy_state >= YYLAST ||
					yychk[ yy_state =
					yyact[ yy_state ] ] != -yy_n )
				{
					yy_state = yyact[ yypgo[ yy_n ] ];
				}
				goto yy_stack;
			}
			yy_len >>= 1;
			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
				*( yy_ps -= yy_len ) + 1;
			if ( yy_state >= YYLAST ||
				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
			{
				yy_state = yyact[ yypgo[ yy_n ] ];
			}
		}
					/* save until reenter driver code */
		yystate = yy_state;
		yyps = yy_ps;
		yypv = yy_pv;
	}
	/*
	** code supplied by user is placed in this switch
	*/
	switch( yytmp )
	{
		
case 1:
# line 93 "cmd.y"
{ if (interact_mode) printf(">> "); fflush(stdout); } break;
case 2:
# line 95 "cmd.y"
{ if (interact_mode) printf(">> "); fflush(stdout); } break;
case 3:
# line 96 "cmd.y"
{} break;
case 4:
# line 97 "cmd.y"
{} break;
case 5:
# line 99 "cmd.y"
{ 
  if (interact_mode) {
    printf("syntax error\n>> ");
    fflush(stdout); /* MyRefresh(); */
  }
  else {
    yyerror();
    exit(1);
  }
} break;
case 6:
# line 115 "cmd.y"
{} break;
case 7:
# line 121 "cmd.y"
{ add_var(&variables,yypvt[-0].strV,TRUE,0); } break;
case 8:
# line 122 "cmd.y"
{ del_list_vars(&tmp_vars); } break;
case 9:
# line 123 "cmd.y"
{ del_list_vars(&tmp_vars); } break;
case 10:
# line 124 "cmd.y"
{ del_var(&variables,yypvt[-0].strV); } break;
case 11:
# line 125 "cmd.y"
{ del_var(&variables,yypvt[-0].strV); } break;
case 12:
# line 126 "cmd.y"
{ list_vars(variables); } break;
case 13:
# line 127 "cmd.y"
{ add_fam(yypvt[-5].strV, yypvt[-5].strV, yypvt[-1].strL); } break;
case 14:
# line 128 "cmd.y"
{ list_struct(variables, empty); } break;
case 15:
# line 129 "cmd.y"
{ list_informativity(yypvt[-0].strV); } break;
case 16:
# line 130 "cmd.y"
{ print_short = yypvt[-0].intV; } break;
case 17:
# line 132 "cmd.y"
{ var_type *v; FIND_VAR(v,yypvt[-0].strV); if (v!=NULL) v->ctype=ct_nominal; } break;
case 18:
# line 134 "cmd.y"
{ var_type *v; FIND_VAR(v,yypvt[-0].strV); if (v!=NULL) v->ctype=ct_contin; } break;
case 19:
# line 137 "cmd.y"
{ printf("Struct %s %s diff %6.3lf\n", yypvt[-1].strV, yypvt[-0].strV, compare_struct_dist(yypvt[-1].strV, yypvt[-0].strV)); } break;
case 20:
# line 139 "cmd.y"
{ printf("Leaves %s %d\n", yypvt[-0].strV, count_id_leaves(yypvt[-0].strV)); } break;
case 21:
# line 141 "cmd.y"
{ double d;
  int n = count_id_inodes(yypvt[-0].strV,&d);
  printf("INodes %s %d(%5.2lf)\n", yypvt[-0].strV, n, d); } break;
case 22:
# line 149 "cmd.y"
{ add_qdesc_varlist(yypvt[-4].strL, yypvt[-1].strL); } break;
case 23:
# line 150 "cmd.y"
{ rename_desc(yypvt[-4].strV, yypvt[-2].strV, yypvt[-0].strV); } break;
case 24:
# line 152 "cmd.y"
{ rename_desc(cfam->out->name,yypvt[-2].strV,yypvt[-0].strV); } break;
case 25:
# line 154 "cmd.y"
{ add_fdesc_var(yypvt[-10].strV,yypvt[-8].strV,left,yypvt[-5].doubV,yypvt[-3].doubV,yypvt[-1].doubV,0); } break;
case 26:
# line 156 "cmd.y"
{ add_fdesc_var(yypvt[-10].strV,yypvt[-8].strV,right,yypvt[-5].doubV,yypvt[-3].doubV,yypvt[-1].doubV,0); } break;
case 27:
# line 158 "cmd.y"
{ add_fdesc_var(yypvt[-12].strV,yypvt[-10].strV,regular,yypvt[-7].doubV,yypvt[-5].doubV,yypvt[-3].doubV,yypvt[-1].doubV); } break;
case 28:
# line 159 "cmd.y"
{ add_idesc_var(yypvt[-4].strV, yypvt[-1].numL); } break;
case 29:
# line 161 "cmd.y"
{ derive_int_using_itable(yypvt[-0].strV, yypvt[-2].varL); } break;
case 30:
# line 163 "cmd.y"
{
#ifdef CBIG
  learn_intervals(yypvt[-2].strV, yypvt[-0].strV); 
#endif
} break;
case 31:
# line 168 "cmd.y"
{ list_var_desc(variables); } break;
case 32:
# line 169 "cmd.y"
{ plot_var_desc(variables); } break;
case 33:
# line 175 "cmd.y"
{ encode_rules = yypvt[-0].erV; } break;
case 34:
# line 176 "cmd.y"
{ add_fam(yypvt[-6].strV, yypvt[-4].strV, yypvt[-1].strL); } break;
case 35:
# line 177 "cmd.y"
{ list_fams(); } break;
case 36:
# line 178 "cmd.y"
{ list_rules(yypvt[-2].strV, yypvt[-0].strV); } break;
case 37:
# line 180 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    list_rules(cfam->name, cfam->out->name);
} break;
case 38:
# line 187 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    list_rules(cfam->name, cfam->out->name);
} break;
case 39:
# line 194 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    list_rules_vect(cfam);
} break;
case 40:
# line 201 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    list_rules(cfam->name, cfam->out->name);
} break;
case 41:
# line 208 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    sort_rules(cfam);
} break;
case 42:
# line 215 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    plot_rules(cfam->name, cfam->out->name);
} break;
case 43:
# line 222 "cmd.y"
{
  cfam = find_fam(yypvt[-0].strV, yypvt[-2].strV);
} break;
case 44:
# line 226 "cmd.y"
{
  if (cfam==NULL)
    printf("no FAM current\n");
  else
    printf("FAM %s for %s\n", cfam->name, cfam->out->name);
} break;
case 45:
# line 233 "cmd.y"
{
  add_rule_num(yypvt[-6].strV, yypvt[-4].strV, yypvt[-2].doubV, yypvt[-0].strV);
} break;
case 46:
# line 237 "cmd.y"
{
  add_rule_num(cfam->name, cfam->out->name, (int) yypvt[-2].doubV, yypvt[-0].strV);
} break;
case 47:
# line 241 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else {
    Str255 s;
    sprintf(s, "%d", (int)yypvt[-0].doubV);
    add_rule_num(cfam->name, cfam->out->name, (int) yypvt[-2].doubV, s);
  }
} break;
case 48:
# line 251 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    add_rule_str(cfam->name, cfam->out->name, yypvt[-1].strL);
} break;
case 49:
# line 258 "cmd.y"
{
  set_apriory(cfam);
} break;
case 50:
# line 262 "cmd.y"
{
  set_apriory_id(yypvt[-0].strV);
} break;
case 51:
# line 266 "cmd.y"
{
  set_apriory(cfam);
} break;
case 52:
# line 270 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else {
    int n = (int) yypvt[-0].intV;
    if (cfam->er == er_table) {
      if (n<0 || n>=cfam->n_rules)
	printf("error: illegal rule number %d\n", n);
      else 
	cfam->rtp[n] = undef;
    }
    else if (cfam->er == er_list) {
      rule_list *rl, *lrl;
      int i;
      if (n==0) cfam->lrule = cfam->lrule->next;
      else {
	rl = lrl = cfam->lrule;
	for (i=0; i<n; i++, rl=rl->next)
	  lrl =rl;
	lrl->next = rl->next;
      }
    }
  }
} break;
case 53:
# line 295 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    del_rule_str(cfam->name, cfam->out->name, yypvt[-1].strL);
} break;
case 54:
# line 302 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    del_rules(cfam);
} break;
case 55:
# line 309 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    if (yypvt[-2].doubV<cfam->n_rules && yypvt[-2].doubV>=0 && yypvt[-0].doubV>=0 && yypvt[-0].doubV<=1)
      cfam->imp[(int)yypvt[-2].doubV] = yypvt[-0].doubV;
    else
      printf("error: parameters out of range\n");
} break;
case 56:
# line 318 "cmd.y"
{ reset_rule_usage(yypvt[-0].strV);} break;
case 57:
# line 319 "cmd.y"
{ printf("Number %lf\n", yypvt[-0].doubV); } break;
case 58:
# line 320 "cmd.y"
{ printf("Id %s\n", yypvt[-0].strV); } break;
case 59:
# line 321 "cmd.y"
{ test_duplicates(yypvt[-0].strV); } break;
case 60:
# line 322 "cmd.y"
{ merge_duplicates(yypvt[-0].strV); } break;
case 61:
# line 323 "cmd.y"
{ expand_rules(cfam); } break;
case 62:
# line 324 "cmd.y"
{ extern double min_exp_w;
					  min_exp_w=yypvt[-0].doubV;
					  expand_rules(cfam); } break;
case 63:
# line 332 "cmd.y"
{ list_tables(); } break;
case 64:
# line 334 "cmd.y"
{ copy_to_table(yypvt[-3].strV, yypvt[-0].strV); } break;
case 65:
# line 336 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    copy_to_table(cfam->out->name, yypvt[-0].strV);
} break;
case 66:
# line 342 "cmd.y"
{ del_table(yypvt[-0].strV); } break;
case 67:
# line 343 "cmd.y"
{ list_table(yypvt[-0].strV); } break;
case 68:
# line 345 "cmd.y"
{ copy_table(yypvt[-2].strV, yypvt[-0].strV, yypvt[-6].doubV); } break;
case 69:
# line 347 "cmd.y"
{ split_rules(yypvt[-4].strV, yypvt[-2].strV, yypvt[-0].strV, yypvt[-7].doubV); } break;
case 70:
# line 348 "cmd.y"
{ copy_table(yypvt[-2].strV, yypvt[-0].strV, 100); } break;
case 71:
# line 349 "cmd.y"
{ compare_table_var(yypvt[-0].strV, yypvt[-3].strV); } break;
case 72:
# line 350 "cmd.y"
{ count_id_rules(yypvt[-0].strV); } break;
case 73:
# line 351 "cmd.y"
{ list_apriory(cfam); } break;
case 74:
# line 356 "cmd.y"
{ derive_dec_tree(yypvt[-0].strV,0); } break;
case 75:
# line 357 "cmd.y"
{ derive_dec_tree(yypvt[-1].strV,0); } break;
case 76:
# line 358 "cmd.y"
{ derive_dec_tree(yypvt[-1].strV,1); } break;
case 77:
# line 359 "cmd.y"
{ derive_dec_tree(yypvt[-1].strV,2); } break;
case 78:
# line 360 "cmd.y"
{ derive_dec_tree(yypvt[-1].strV,3); } break;
case 79:
# line 362 "cmd.y"
{ list_dec_tree(yypvt[-0].strV); } break;
case 80:
# line 368 "cmd.y"
{ repeat_tests = (int) yypvt[-0].doubV; } break;
case 81:
# line 369 "cmd.y"
{ save_tests = yypvt[-0].chV; } break;
case 82:
# line 371 "cmd.y"
{
  test_decomposition(yypvt[-9].strV, yypvt[-0].strV, (int)yypvt[-7].doubV, (int)yypvt[-5].doubV, (int)yypvt[-3].doubV);
} break;
case 83:
# line 374 "cmd.y"
{ dec_global = FALSE; } break;
case 84:
# line 375 "cmd.y"
{ dec_global = TRUE; } break;
case 85:
# line 377 "cmd.y"
{ dec_crit = c_cm; } break;
case 86:
# line 378 "cmd.y"
{ dec_crit = c_dfc; } break;
case 87:
# line 379 "cmd.y"
{ dec_crit = c_error; } break;
case 88:
# line 380 "cmd.y"
{ dec_crit = c_m; } break;
case 89:
# line 381 "cmd.y"
{ dec_crit = c_r; } break;
case 90:
# line 382 "cmd.y"
{ dec_crit = c_cr; } break;
case 91:
# line 385 "cmd.y"
{ n_dis_lo = n_dis_hi = yypvt[-0].intV; } break;
case 92:
# line 386 "cmd.y"
{ n_dis_lo = yypvt[-2].intV; n_dis_hi = yypvt[-0].intV; } break;
case 93:
# line 388 "cmd.y"
{ n_dis_lo = n_dis_hi = yypvt[-2].intV; n_ndis_lo = n_ndis_hi = yypvt[-0].intV; } break;
case 94:
# line 390 "cmd.y"
{ n_dis_lo = yypvt[-6].intV; n_dis_hi = yypvt[-4].intV; n_ndis_lo = yypvt[-2].intV; n_ndis_hi = yypvt[-0].intV; } break;
case 95:
# line 391 "cmd.y"
{ check_redundant(yypvt[-0].strV, FALSE, NULL); } break;
case 96:
# line 392 "cmd.y"
{ check_redundant(yypvt[-0].strV, TRUE, NULL); } break;
case 97:
# line 394 "cmd.y"
{ del_redundant_sorted(yypvt[-0].strV, M_INFORM, NULL); } break;
case 98:
# line 396 "cmd.y"
{ del_redundant_sorted(yypvt[-0].strV, M_GINI, NULL); } break;
case 99:
# line 398 "cmd.y"
{ del_redundant_sorted(yypvt[-0].strV, M_GR, NULL); } break;
case 100:
# line 400 "cmd.y"
{ del_redundant_sorted(yypvt[-0].strV, M_RELIEFF, NULL); } break;
case 101:
# line 402 "cmd.y"
{ check_redundant(yypvt[-2].strV, FALSE, yypvt[-0].varL); } break;
case 102:
# line 404 "cmd.y"
{ check_redundant(yypvt[-2].strV, TRUE, yypvt[-0].varL); } break;
case 103:
# line 405 "cmd.y"
{ log_inform = !log_inform; } break;
case 104:
# line 406 "cmd.y"
{ log_relieff = !log_relieff; } break;
case 105:
# line 407 "cmd.y"
{ log_gini = !log_gini; } break;
case 106:
# line 408 "cmd.y"
{ log_gr = !log_gr; } break;
case 107:
# line 409 "cmd.y"
{ log_mdl = !log_mdl; } break;
case 108:
# line 410 "cmd.y"
{ deb_inform = yypvt[-0].chV; } break;
case 109:
# line 411 "cmd.y"
{ deb_relieff = yypvt[-0].chV; } break;
case 110:
# line 412 "cmd.y"
{ deb_gini = yypvt[-0].chV; } break;
case 111:
# line 413 "cmd.y"
{ deb_gr = yypvt[-0].chV; } break;
case 112:
# line 414 "cmd.y"
{ use_dm = yypvt[-0].chV; } break;
case 113:
# line 416 "cmd.y"
{ printf("dfc %s is %d\n", yypvt[-0].strV, get_dfc_measure(yypvt[-0].strV)); } break;
case 114:
# line 418 "cmd.y"
{ printf("sdtic %s is %5.3lf\n", yypvt[-0].strV, get_code_measure(yypvt[-0].strV)); } break;
case 115:
# line 420 "cmd.y"
{
  extern double get_dtic_measure(Str255 vname);
  printf("dtic %s is %5.3lf\n", yypvt[-0].strV, get_dtic_measure(yypvt[-0].strV));
} break;
case 116:
# line 425 "cmd.y"
{ fast_decompose(yypvt[-1].strV, M_INFORM, (int)yypvt[-0].intV); } break;
case 117:
# line 426 "cmd.y"
{ fast_decompose(yypvt[-1].strV, M_GINI, yypvt[-0].intV); } break;
case 118:
# line 427 "cmd.y"
{ fast_decompose(yypvt[-1].strV, M_GR, yypvt[-0].intV); } break;
case 119:
# line 428 "cmd.y"
{ fast_decompose(yypvt[-1].strV, M_RELIEFF, yypvt[-0].intV); } break;
case 120:
# line 429 "cmd.y"
{ fast_decompose(yypvt[-1].strV, M_MDL, yypvt[-0].intV); } break;
case 121:
# line 433 "cmd.y"
{
  /* this is to use new IM derivation procedure */
  extern char dec_speed;
  dec_speed = yypvt[-0].intV;
} break;
case 122:
# line 443 "cmd.y"
{ list_struct(variables, curropt); } break;
case 123:
# line 444 "cmd.y"
{ list_options(); } break;
case 124:
# line 445 "cmd.y"
{ del_opt(yypvt[-0].strV); } break;
case 125:
# line 446 "cmd.y"
{ set_opt(yypvt[-0].strV); } break;
case 126:
# line 447 "cmd.y"
{ select_opt(yypvt[-0].strV); } break;
case 127:
# line 450 "cmd.y"
{
  Str255 s;
  if (pref_qual) {
    sprintf(s, "%d", (int)yypvt[-0].doubV);
    set_var_val_q(yypvt[-2].strV,s);
  }
  else set_var_val_num(yypvt[-2].strV, yypvt[-0].doubV);
} break;
case 128:
# line 458 "cmd.y"
{ set_var_val_qlist(yypvt[-4].strV, yypvt[-1].strQ); } break;
case 129:
# line 459 "cmd.y"
{ set_var_val_q(yypvt[-2].strV,yypvt[-0].strV); } break;
case 130:
# line 460 "cmd.y"
{ set_var_expect(yypvt[-2].strV, yypvt[-0].doubV); } break;
case 131:
# line 461 "cmd.y"
{ evaluate(yypvt[-0].strV); } break;
case 132:
# line 463 "cmd.y"
{
  if (find_opt(yypvt[-0].strV, TRUE) != NULL) {
    select_opt(yypvt[-0].strV);
    evaluate(yypvt[-2].strV);
    set_opt(yypvt[-0].strV);
  }
} break;
case 133:
# line 470 "cmd.y"
{ derive_lvar(yypvt[-0].varL); } break;
case 134:
# line 472 "cmd.y"
{
  if (find_opt(yypvt[-0].strV, TRUE) != NULL) {
    select_opt(yypvt[-0].strV);
    derive_lvar(yypvt[-2].varL);
    set_opt(yypvt[-0].strV);
  }
} break;
case 135:
# line 480 "cmd.y"
{
  list_of_opt *opt;
  for (opt=options; opt!=NULL; opt=opt->next) {
    select_opt(opt->name);
    derive_lvar(yypvt[-2].varL);
    set_opt(opt->name);
  }
} break;
case 136:
# line 489 "cmd.y"
{
  list_of_str *s;
  for (s=yypvt[-1].strL; s!=NULL; s=s->next)
    if (find_opt(s->str, TRUE) != NULL) {
      select_opt(s->str);
      derive_lvar(yypvt[-4].varL);
      set_opt(s->str);
    }
} break;
case 137:
# line 498 "cmd.y"
{ list_var_opt_all(yypvt[-2].strV); } break;
case 138:
# line 499 "cmd.y"
{ plot_var_opt_all(yypvt[-0].strV); } break;
case 139:
# line 500 "cmd.y"
{ list_var_opt_str(yypvt[-4].strV, yypvt[-1].strL); } break;
case 140:
# line 502 "cmd.y"
{
				/* BBB try not only to undefine the
                                   whole option, but also just
                                   internal nodes */
  undefine_opt();
} break;
case 141:
# line 508 "cmd.y"
{extern char evaltype; evaltype=yypvt[-0].intV;} break;
case 142:
# line 509 "cmd.y"
{ eval_method = yypvt[-0].evalV; } break;
case 143:
# line 511 "cmd.y"
{ add_itable(yypvt[-6].strV, yypvt[-4].strV, yypvt[-1].strL); } break;
case 144:
# line 512 "cmd.y"
{ list_instance_tables(); } break;
case 145:
# line 513 "cmd.y"
{ list_instance_table(yypvt[-0].strV,FALSE); } break;
case 146:
# line 514 "cmd.y"
{ list_instance_table(yypvt[-0].strV,TRUE); } break;
case 147:
# line 516 "cmd.y"
{ load_instance_from_table((int)yypvt[-2].doubV,yypvt[-0].strV);} break;
case 148:
# line 517 "cmd.y"
{ load_instances_from_table(yypvt[-0].strV); } break;
case 149:
# line 520 "cmd.y"
{ derive_rtable_from_itable(yypvt[-4].strV, yypvt[-0].strV, TRUE); } break;
case 150:
# line 522 "cmd.y"
{ derive_rtable_from_itable(yypvt[-4].strV, yypvt[-0].strV, FALSE); } break;
case 151:
# line 525 "cmd.y"
{ discretize(yypvt[-4].strV, yypvt[-0].strV); } break;
case 152:
# line 528 "cmd.y"
{ split_instance_table(yypvt[-4].strV, yypvt[-2].strV, yypvt[-0].strV, yypvt[-8].doubV); } break;
case 153:
# line 534 "cmd.y"
{ ga_population_size = yypvt[-0].intV; } break;
case 154:
# line 535 "cmd.y"
{ ga_maxiter = yypvt[-0].intV; } break;
case 155:
# line 536 "cmd.y"
{ ga_desc_pts = yypvt[-0].doubV; } break;
case 156:
# line 537 "cmd.y"
{ ga_weight_pts = yypvt[-0].doubV; } break;
case 157:
# line 538 "cmd.y"
{ ga_print_freq = yypvt[-0].doubV; } break;
case 158:
# line 539 "cmd.y"
{ ga_width = yypvt[-0].doubV; } break;
case 159:
# line 540 "cmd.y"
{ ga_max_error = yypvt[-0].doubV; } break;
case 160:
# line 541 "cmd.y"
{ ga_error_method = yypvt[-0].gaeV; } break;
case 161:
# line 542 "cmd.y"
{ fa_method = yypvt[-0].faV; } break;
case 162:
# line 543 "cmd.y"
{ ga_mut_fams = yypvt[-0].doubV; } break;
case 163:
# line 544 "cmd.y"
{ ga_mut_desc = yypvt[-0].doubV; } break;
case 164:
# line 545 "cmd.y"
{ ga_mut_w = yypvt[-0].doubV; } break;
case 165:
# line 546 "cmd.y"
{ ga_cross_fams = yypvt[-0].doubV; } break;
case 166:
# line 547 "cmd.y"
{ ga_cross_desc = yypvt[-0].doubV; } break;
case 167:
# line 548 "cmd.y"
{ ga_cross_w = yypvt[-0].doubV; } break;
case 168:
# line 549 "cmd.y"
{ ga_learn_fams = yypvt[-0].chV; } break;
case 169:
# line 550 "cmd.y"
{ ga_learn_desc = yypvt[-0].chV; } break;
case 170:
# line 551 "cmd.y"
{ ga_learn_w = yypvt[-0].chV; } break;
case 171:
# line 552 "cmd.y"
{ ga_policy = yypvt[-0].gapV; } break;
case 172:
# line 553 "cmd.y"
{} break;
case 173:
# line 554 "cmd.y"
{} break;
case 174:
# line 555 "cmd.y"
{} break;
case 175:
# line 556 "cmd.y"
{} break;
case 176:
# line 558 "cmd.y"
{
#ifdef CBIG
  ga_learn(yypvt[-0].varL);
#endif
} break;
case 177:
# line 563 "cmd.y"
{} break;
case 178:
# line 564 "cmd.y"
{ stat_for_var(yypvt[-0].strV); } break;
case 179:
# line 566 "cmd.y"
{
  printf("Error: %10.5lf\n", stat_for_itable(yypvt[-0].strV));
} break;
case 180:
# line 570 "cmd.y"
{
#ifdef CBIG
  plot_ga_error();
#endif
} break;
case 181:
# line 580 "cmd.y"
{ bottom_up_decompose(yypvt[-0].strV,TRUE,TRUE);} break;
case 182:
# line 582 "cmd.y"
{ 
  if (dec_global) global_decompose(yypvt[-0].strV,TRUE,FALSE);
  else bottom_up_decompose(yypvt[-0].strV,TRUE,FALSE);
} break;
case 183:
# line 587 "cmd.y"
{ compose(yypvt[-0].strV); } break;
case 184:
# line 588 "cmd.y"
{ bottom_up_decompose(yypvt[-0].strV,FALSE,FALSE);} break;
case 185:
# line 590 "cmd.y"
{ decomposition_table(yypvt[-4].strV, yypvt[-2].varL, yypvt[-0].varL); } break;
case 186:
# line 593 "cmd.y"
{ join_nodes(yypvt[-4].varL,NULL,yypvt[-2].strV,yypvt[-0].strV,0); } break;
case 187:
# line 595 "cmd.y"
{ join_nodes(yypvt[-6].varL,yypvt[-4].varL,yypvt[-2].strV,yypvt[-0].strV,0); } break;
case 188:
# line 597 "cmd.y"
{ join_nodes(yypvt[-4].varL,NULL,yypvt[-2].strV,yypvt[-0].strV,1); } break;
case 189:
# line 599 "cmd.y"
{ join_nodes(yypvt[-6].varL,yypvt[-4].varL,yypvt[-2].strV,yypvt[-0].strV,1); } break;
case 190:
# line 601 "cmd.y"
{ join_nodes(NULL,NULL,NULL,NULL,2); } break;
case 191:
# line 603 "cmd.y"
{ heur_split = yypvt[-0].chV; } break;
case 192:
# line 604 "cmd.y"
{ heur_comp = yypvt[-0].chV; } break;
case 193:
# line 605 "cmd.y"
{ deb_dec = yypvt[-0].intV; } break;
case 194:
# line 606 "cmd.y"
{ krelieff = yypvt[-0].doubV; } break;
case 195:
# line 608 "cmd.y"
{ coloring = yypvt[-0].colV; } break;
case 196:
# line 610 "cmd.y"
{ save_im = yypvt[-0].chV; } break;
case 197:
# line 611 "cmd.y"
{ strcpy(im_fname, yypvt[-0].strV); } break;
case 198:
# line 612 "cmd.y"
{ analyze_current_color(); } break;
case 199:
# line 613 "cmd.y"
{ list_current_color(); } break;
case 200:
# line 614 "cmd.y"
{ list_color_groups(); } break;
case 201:
# line 615 "cmd.y"
{ list_unsure_instances(); } break;
case 202:
# line 616 "cmd.y"
{ list_ndm(); } break;
case 203:
# line 617 "cmd.y"
{ set_instance_to_color((int)yypvt[-2].doubV, (int)yypvt[-0].doubV); } break;
case 204:
# line 619 "cmd.y"
{ set_color(yypvt[-0].strV); } break;
case 205:
# line 620 "cmd.y"
{ set_sure_color(); } break;
case 206:
# line 621 "cmd.y"
{ set_need_color(); } break;
case 207:
# line 622 "cmd.y"
{ set_same_color((int)yypvt[-1].doubV,(int)yypvt[-0].doubV); } break;
case 208:
# line 623 "cmd.y"
{ set_diff_color((int)yypvt[-1].doubV,(int)yypvt[-0].doubV); } break;
case 209:
# line 625 "cmd.y"
{ extern char use_evidence;
					  use_evidence = TRUE;
					} break;
case 210:
# line 633 "cmd.y"
{ add_noise(yypvt[-0].strV, yypvt[-4].doubV); } break;
case 211:
# line 634 "cmd.y"
{ m_param = yypvt[-0].doubV; } break;
case 212:
# line 636 "cmd.y"
{ get_class_error();} break;
case 213:
# line 637 "cmd.y"
{ test(yypvt[-0].doubV,0);} break;
case 214:
# line 638 "cmd.y"
{ test(yypvt[-1].doubV,yypvt[-0].doubV);} break;
case 215:
# line 640 "cmd.y"
{ double e, m; 
				  int c=get_partition_error(&e,&m);
				printf("FIN c=%d e=%6.2lf %5.2lf\n", c, e,m);} break;
case 216:
# line 643 "cmd.y"
{ merge_colors(yypvt[-1].intV, yypvt[-0].intV, -1.); } break;
case 217:
# line 644 "cmd.y"
{ repeat_merge(-1); } break;
case 218:
# line 645 "cmd.y"
{ repeat_merge(yypvt[-0].intV); } break;
case 219:
# line 646 "cmd.y"
{ test_merge(yypvt[-3].doubV, yypvt[-2].doubV, yypvt[-0].doubV); } break;
case 220:
# line 647 "cmd.y"
{ printf("Error: %7.3lf\n", 
					 get_class_error()); } break;
case 221:
# line 650 "cmd.y"
{ int i, j; double d;
				  select_pair(&i, &j, &d);
				} break;
case 222:
# line 653 "cmd.y"
{ noise_handling = n_mprob; } break;
case 223:
# line 654 "cmd.y"
{ noise_handling = n_mprob;
					  m_dec = m_cm; } break;
case 224:
# line 656 "cmd.y"
{ noise_handling = n_mprob;
					  m_dec = m_error; } break;
case 225:
# line 658 "cmd.y"
{ noise_handling = n_mprob;
					  m_dec = m_cm_error; } break;
case 226:
# line 660 "cmd.y"
{ noise_handling = n_entropy; } break;
case 227:
# line 661 "cmd.y"
{ noise_handling = n_laplace; } break;
case 228:
# line 662 "cmd.y"
{ noise_handling = n_cluster; } break;
case 229:
# line 664 "cmd.y"
{ dont_care = dc_dont_care; } break;
case 230:
# line 665 "cmd.y"
{ dont_care = dc_dont_know; } break;
case 231:
# line 666 "cmd.y"
{ dont_care = dc_apriory; } break;
case 232:
# line 668 "cmd.y"
{ srand((int)yypvt[-0].doubV); } break;
case 233:
# line 670 "cmd.y"
{ use_distribution=!use_distribution; } break;
case 234:
# line 671 "cmd.y"
{ test_type = t_cv; } break;
case 235:
# line 672 "cmd.y"
{ int extern n_folds;
					  test_type = t_cv;
					  n_folds = (int)yypvt[-0].intV;
					} break;
case 236:
# line 676 "cmd.y"
{ test_type = t_sample; } break;
case 237:
# line 677 "cmd.y"
{ extern int n_folds;
					  extern double p_sample_l, p_sample_mut;
					  test_type = t_sample;
					  p_sample_l = yypvt[-2].doubV; p_sample_mut = yypvt[-1].doubV;
					  n_folds = (int)yypvt[-0].intV;
					} break;
case 238:
# line 684 "cmd.y"
{ prepare_cv(yypvt[-0].strV, yypvt[-2].intV); } break;
case 239:
# line 686 "cmd.y"
{ split_using_cv(yypvt[-6].strV, yypvt[-4].strV, yypvt[-2].strV, yypvt[-0].intV); } break;
case 240:
# line 687 "cmd.y"
{ char extern sel_mfreq; sel_mfreq=TRUE; } break;
case 241:
# line 688 "cmd.y"
{ char extern sel_mfreq; sel_mfreq=FALSE; } break;
case 242:
# line 696 "cmd.y"
{
  FILE *f;

  if (myno_files == MY_MAX_FILES) {
    printf("error: no of files to be loaded exceeded the limit\n");
    exit(0);
  }
  printf("load %s\n", yypvt[-0].strV);
  f = fopen(yypvt[-0].strV, "r");
  if (f == NULL) {
    printf("error: could not open %s as cmd file\n", yypvt[-0].strV);
  }
  else {
    myno_files++;
    myfiles[myno_files].f = yyin;
    myfiles[myno_files].lineno = yylineno;
    yyin = f;
    yylineno = 1;
    interact_mode = FALSE;
  }
} break;
case 243:
# line 722 "cmd.y"
{ load_irules(yypvt[-0].strV, cfam, 0); set_apriory(cfam); } break;
case 244:
# line 724 "cmd.y"
{ load_irules(yypvt[-2].strV, cfam, yypvt[-0].intV); set_apriory(cfam); } break;
case 245:
# line 729 "cmd.y"
{ save_struct(yypvt[-0].strV); } break;
case 246:
# line 730 "cmd.y"
{ save_des(yypvt[-0].strV); } break;
case 247:
# line 731 "cmd.y"
{ save_rules(yypvt[-0].strV); } break;
case 248:
# line 732 "cmd.y"
{ save_opt(yypvt[-0].strV); } break;
case 249:
# line 733 "cmd.y"
{ save_all(yypvt[-0].strV); } break;
case 250:
# line 735 "cmd.y"
{ save_c45_rules(yypvt[-2].strV,yypvt[-0].strV);
					  save_c45_names(yypvt[-2].strV,yypvt[-0].strV);
					} break;
case 251:
# line 739 "cmd.y"
{
  Str255 s1, s2;
  save_c45_names(yypvt[-3].strV,yypvt[-0].strV);
  strcpy(s1,yypvt[-0].strV);
  save_c45_rules(yypvt[-3].strV,strcat(yypvt[-0].strV,".data"));
  save_c45_rules(yypvt[-2].strV,strcat(s1,".test"));
} break;
case 252:
# line 746 "cmd.y"
{ save_c45_rules(yypvt[-2].strV,yypvt[-0].strV); } break;
case 253:
# line 747 "cmd.y"
{ save_c45_names(yypvt[-2].strV,yypvt[-0].strV); } break;
case 254:
# line 748 "cmd.y"
{ save_dot_struct(yypvt[-2].strV,yypvt[-0].strV); } break;
case 255:
# line 754 "cmd.y"
{				/* select fam or option -> FIFO  */
  var_type *v;
  list_of_opt *opt;

  if (((v = find_var(variables,yypvt[-0].strV)) != NULL) &&
      find_fam(yypvt[-0].strV, v->name) != NULL)
    cfam = find_fam(yypvt[-0].strV, v->name);
  else if (find_opt(yypvt[-0].strV,TRUE)) {
    opt = find_opt(yypvt[-0].strV,TRUE);
    if (opt != NULL)
      select_opt(yypvt[-0].strV);
    else
      printf("error: not found, neither a FAM nor an option\n");
  }
} break;
case 256:
# line 770 "cmd.y"
{
  printf("GENETIC ALGORITHM:\n");
  printf("population size    %d\n", ga_population_size);
  printf("max iterations     %d\n", ga_maxiter);
  printf("description points %d\n", ga_desc_pts);
  printf("weight points      %d\n", ga_weight_pts);
  printf("print freq         %d\n", ga_print_freq);
  printf("width (desc enlar) %lf\n", ga_width);
  printf("policy (cross,mut) %s\n",
	 ga_policy==gap_or?"or":(ga_policy==gap_and?"and":"custom"));
  printf("max plot error     %lf\n", ga_max_error);
  printf("error measure      %s\n",
	 (ga_error_method==gae_abs)?"abs":
	 (ga_error_method==gae_norm)?"norm":
	 (ga_error_method==gae_sqr)?"sqr":
	 (ga_error_method==gae_perc)?"perc":
	 (ga_error_method==gae_sqrperc)?"sqr perc":"max perc");
  printf("mutation probab    %5.2lf/L (fams) %5.2lf/L (desc) %5.2lf/L (w)\n",
	 ga_mut_fams, ga_mut_desc, ga_mut_w);
  printf("crossover probab   %5.2lf   (fams) %5.2lf   (desc) %5.2lf   (w)\n",
	 ga_cross_fams, ga_cross_desc, ga_cross_w);
  printf("learn              %s   (fams) %s   (desc) %s   (w)\n",
	 ga_learn_fams?" yes ":" no  ",
	 ga_learn_desc?" yes ":" no  ",
	 ga_learn_w?" yes ":" no  ");

  printf("\nDEBUGGING:\n");
  printf("evaluate           %s\n", debug_e ? "yes" : "no");
  printf("lexical analysis   %s\n", debug_l ? "yes" : "no");
  printf("ga learning        %s\n", debug_g ? "yes" : "no");
  printf("descriptor constr  %s\n", debug_g ? "yes" : "no");
  printf("print length       %d\n", print_short);

  printf("\nEVALUATION:\n");
  printf("fuzzy and          %s\n", (fa_method==famin)?"min" :
	 ((fa_method==famax)?"max":"mult"));

/*  printf("\nFUZZY IDENTIFICATION:\n");
  printf("init num clusters  %d\n", cl_K);
  printf("fuzziness          %5.3lf\n", cl_m);
  printf("merging treshold   %5.3lf\n", cl_gamma); 
  printf("clustering e       %7.5lf\n", cl_e);
  printf("redo the loop      %d\n", cl_redo);
  printf("sigm memberships   %s\n", cl_sigm ? "yes" : "no");
  printf("deb clust proto    %s\n", deb_cl_cp ? "yes" : "no");
  printf("data and partit    %s\n", deb_cl_pm ? "yes" : "no");
  printf("identif matrices   %s\n", deb_cl_f ? "yes" : "no"); */

  printf("\nDECOMPOSITION:\n");
  printf("coloring           %s\n", coloring==col_optimal ? "opt" :
	 coloring==col_heuristic ? "heuristic" : "ga");
  printf("m-criteria         %lf\n", mcriteria);
  printf("heuristic compute  %s\n", heur_comp ? "yes" : "no");
  printf("heuristic split    %s\n", heur_split ? "yes" : "no");
  printf("dec debug          %d\n", deb_dec);
  printf("k for NN relieff   %d\n", krelieff);
  printf("log informativity  %s\n", log_inform ? "yes" : "no");
  printf("log relieff        %s\n", log_relieff ? "yes" : "no");
  printf("log gini           %s\n", log_gini ? "yes" : "no");
  printf("log gain-ratio     %s\n", log_gr ? "yes" : "no");
  printf("debug inform       %s\n", deb_inform ? "yes" : "no");
  printf("debug relieff      %s\n", deb_relieff ? "yes" : "no");
  printf("debug gini         %s\n", deb_gini ? "yes" : "no");
  printf("debug gain-ratio   %s\n", deb_gr ? "yes" : "no");
  printf("save im            %s\n", save_im ? "yes" : "no");
  printf("save im file name  %s\n", im_fname);
  printf("bound              %d to %d\n", n_dis_lo, n_dis_hi);

  printf("\nEVALUATION / DATA REPRESENTATION:\n");
  printf("encoding rules     %s\n", encode_rules==er_table? "as table" :
	 encode_rules==er_list? "as list" : "as tree");
  printf("use dm             %s\n", use_dm?"yes":"no");
  printf("eval method        %s\n", eval_method==e_crisp? "crisp" :
	 eval_method==e_fuzzy? "fuzzy" :
	 eval_method==e_numerical? "numerical" : "interval");
  printf("entry preference   %s\n", pref_qual?"qualitative":"quantitative");
  printf("test repetition    %d\n", repeat_tests);
  printf("var prefix         %s\n", prefix_var);
  printf("opt prefix         %s\n", prefix_opt);
} break;
case 257:
# line 850 "cmd.y"
{ debug_e = TRUE;} break;
case 258:
# line 852 "cmd.y"
{ debug_g = TRUE;} break;
case 259:
# line 853 "cmd.y"
{ debug_d = TRUE;} break;
case 260:
# line 854 "cmd.y"
{ pref_qual = TRUE; } break;
case 261:
# line 855 "cmd.y"
{ pref_qual = FALSE; } break;
case 262:
# line 856 "cmd.y"
{ strcpy(prefix_var, yypvt[-0].strV); iprefix_var=1; } break;
case 263:
# line 857 "cmd.y"
{ strcpy(prefix_opt, yypvt[-0].strV); iprefix_opt=1; } break;
case 264:
# line 859 "cmd.y"
{
/*  struct tms bbuf, ebuf;
  times(&bbuf);
  times(&ebuf);
  while (((float)(ebuf.tms_utime-bbuf.tms_utime)/60) < $2)
    times(&ebuf); */
} break;
case 265:
# line 866 "cmd.y"
{ printf("%s\n", yypvt[-0].strV); } break;
case 266:
# line 867 "cmd.y"
{ fprintf(lfile, "%s\n", yypvt[-0].strV); } break;
case 267:
# line 868 "cmd.y"
{ color_graph(); } break;
case 268:
# line 869 "cmd.y"
{ exit(1); } break;
case 269:
# line 872 "cmd.y"
{ yyval.chV=TRUE; } break;
case 270:
# line 873 "cmd.y"
{ yyval.chV=FALSE; } break;
case 271:
# line 876 "cmd.y"
{ yyval.faV=famin; } break;
case 272:
# line 877 "cmd.y"
{ yyval.faV=famax; } break;
case 273:
# line 878 "cmd.y"
{ yyval.faV=famult; } break;
case 274:
# line 881 "cmd.y"
{ yyval.evalV=e_fuzzy; } break;
case 275:
# line 882 "cmd.y"
{ yyval.evalV=e_crisp; } break;
case 276:
# line 883 "cmd.y"
{ yyval.evalV=e_interval; } break;
case 277:
# line 886 "cmd.y"
{ yyval.colV=col_optimal; } break;
case 278:
# line 887 "cmd.y"
{ yyval.colV=col_heuristic; } break;
case 279:
# line 888 "cmd.y"
{ yyval.colV=col_ga; } break;
case 280:
# line 889 "cmd.y"
{ yyval.colV=col_set; } break;
case 281:
# line 892 "cmd.y"
{ yyval.gaeV=gae_abs; } break;
case 282:
# line 893 "cmd.y"
{ yyval.gaeV=gae_sqr; } break;
case 283:
# line 894 "cmd.y"
{ yyval.gaeV=gae_perc; } break;
case 284:
# line 895 "cmd.y"
{ yyval.gaeV=gae_sqrperc; } break;
case 285:
# line 896 "cmd.y"
{ yyval.gaeV=gae_maxperc; } break;
case 286:
# line 897 "cmd.y"
{ yyval.gaeV=gae_norm; } break;
case 287:
# line 900 "cmd.y"
{ yyval.gapV=gap_and; } break;
case 288:
# line 901 "cmd.y"
{ yyval.gapV=gap_or; } break;
case 289:
# line 902 "cmd.y"
{ yyval.gapV=gap_custom; } break;
case 290:
# line 905 "cmd.y"
{} break;
case 291:
# line 906 "cmd.y"
{} break;
case 292:
# line 910 "cmd.y"
{
  add_var(&tmp_vars, yypvt[-0].strV, FALSE, 0);
  add_var(&variables, yypvt[-0].strV, FALSE, 0);
} break;
case 293:
# line 918 "cmd.y"
{
  list_of_str *sl, *slt;

  slt = NULL;
  for (sl=yypvt[-0].strL; sl!=NULL; sl=sl->prev) {
    sl->next = slt;
    slt = sl;
  }
  yyval.strL = slt;
} break;
case 294:
# line 931 "cmd.y"
{
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  strcpy(yyval.strL->str, yypvt[-0].strV);
  yyval.strL->prev = yypvt[-2].strL;
} break;
case 295:
# line 938 "cmd.y"
{
  Str255 s;
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  sprintf(s, "%lf", yypvt[-0].doubV);
  strcpy(yyval.strL->str, s);
  yyval.strL->prev = yypvt[-2].strL;
} break;
case 296:
# line 947 "cmd.y"
{
  Str255 s;
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  sprintf(s, "%d", (int)yypvt[-0].intV);
  strcpy(yyval.strL->str, s);
  yyval.strL->prev = yypvt[-2].strL;
} break;
case 297:
# line 956 "cmd.y"
{
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  strcpy(yyval.strL->str, "?");
  yyval.strL->prev = yypvt[-2].strL;
} break;
case 298:
# line 963 "cmd.y"
{
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  strcpy(yyval.strL->str, yypvt[-0].strV);
  yyval.strL->prev = NULL;
} break;
case 299:
# line 970 "cmd.y"
{
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  strcpy(yyval.strL->str, "?");
  yyval.strL->prev = NULL;
} break;
case 300:
# line 977 "cmd.y"
{
  Str255 s;
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  sprintf(s, "%d", (int)yypvt[-0].doubV);
  strcpy(yyval.strL->str, s);
  yyval.strL->prev = NULL;
} break;
case 301:
# line 986 "cmd.y"
{
  Str255 s;
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  sprintf(s, "%d", (int)yypvt[-0].intV);
  strcpy(yyval.strL->str, s);
  yyval.strL->prev = NULL;
} break;
case 302:
# line 997 "cmd.y"
{
  list_of_num *sl, *slt;

  slt = NULL;
  for (sl=yypvt[-0].numL; sl!=NULL; sl=sl->prev) {
    sl->next = slt;
    slt = sl;
  }
  yyval.numL = slt;
} break;
case 303:
# line 1010 "cmd.y"
{
  yyval.numL = (list_of_num *) malloc(sizeof(*yyval.numL));
  yyval.numL->num = yypvt[-0].doubV;
  yyval.numL->prev = yypvt[-2].numL;
} break;
case 304:
# line 1016 "cmd.y"
{
  yyval.numL = (list_of_num *) malloc(sizeof(*yyval.numL));
  yyval.numL->num = yypvt[-0].doubV;
  yyval.numL->prev = NULL;
} break;
case 314:
# line 1028 "cmd.y"
{
  list_of_vars *sl, *slt;

  slt = NULL;
  for (sl=yypvt[-0].varL; sl!=NULL; sl=sl->prev) {
    sl->next = slt;
    slt = sl;
  }
  yyval.varL = slt;
} break;
case 315:
# line 1041 "cmd.y"
{
  var_type *v;
  v = find_var(variables,yypvt[-0].strV);
  if (v==NULL) {
    printf("error: %s not found\n", yypvt[-0].strV);
    yyval.varL = yypvt[-2].varL;
  }
  else {
    yyval.varL = (list_of_vars *) malloc(sizeof(*yyval.varL));
    yyval.varL->var = v;
    yyval.varL->prev = yypvt[-2].varL;
  }
} break;
case 316:
# line 1055 "cmd.y"
{
  var_type *v;
  v = find_var(variables,yypvt[-0].strV);
  if (v==NULL) {
    printf("error: %s not found\n", yypvt[-0].strV);
    yyval.varL = NULL;
  }
  else {
    yyval.varL = (list_of_vars *) malloc(sizeof(*yyval.varL));
    yyval.varL->var = v;
    yyval.varL->prev = NULL;;
  }
} break;
case 317:
# line 1070 "cmd.y"
{
  yypvt[-0].strQ->next = yypvt[-2].strQ;
  yyval.strQ = yypvt[-0].strQ;
} break;
case 318:
# line 1075 "cmd.y"
{
  yyval.strQ = yypvt[-0].strQ;
} break;
case 319:
# line 1081 "cmd.y"
{
  yyval.strQ = (list_of_q *) malloc(sizeof(*yyval.strQ));
  strcpy(yyval.strQ->desc, yypvt[-2].strV);
  yyval.strQ->degree = yypvt[-0].doubV;
  yyval.strQ->next = NULL;
} break;
case 320:
# line 1088 "cmd.y"
{
  Str255 s;
  yyval.strQ = (list_of_q *) malloc(sizeof(*yyval.strQ));
  sprintf(s, "%d", (int)yypvt[-2].doubV);
  strcpy(yyval.strQ->desc, s);
  yyval.strQ->degree = yypvt[-0].doubV;
  yyval.strQ->next = NULL;
} break;
case 325:
# line 1116 "cmd.y"
{
  int j;

  if (att_num == cfam->n_in) {
    for (j=0; j<cfam->out->ndesc 
	 && strcmp(cfam->out->desc[j].name, yypvt[-0].strV);
	 j++);
    if (j<cfam->out->ndesc) set_rule(cfam, att, j, man);
    else {
      printf("error %d: %s not legal qval for %s\n", 
	     yylineno, yypvt[-0].strV, cfam->out->name);
      exit(1);
    }

    att_num = 0;
  }
  else {
    if (!strcmp(yypvt[-0].strV,"?")) {
      att[att_num] = CUNDEF;
    }
    else {
      for (j=0; j<cfam->in[att_num]->ndesc 
	   && strcmp(cfam->in[att_num]->desc[j].name, yypvt[-0].strV);
	   j++);
      if (j<cfam->in[att_num]->ndesc) att[att_num] = j;
      else {
	printf("error_ %d: %s not legal qval for %s\n", 
	       yylineno, yypvt[-0].strV, cfam->in[att_num]->name);
      }
    }
    att_num++;
  }
} break;
case 330:
# line 1164 "cmd.y"
{
  int j;

  if (att_num == cfam->n_in) {
    if (yypvt[-0].intV<0 || yypvt[-0].intV>=cfam->out->ndesc) {
      printf("error i %d: index %d not legal for %s\n", 
	     yylineno, yypvt[-0].intV, cfam->out->name);
      exit(1);
    }
    set_rule(cfam, att, yypvt[-0].intV, man);
    att_num = 0;
  }
  else {
/*    if ($1==CUNDEF)
      att[att_num] = $1; */
    if (yypvt[-0].intV<0 || yypvt[-0].intV>=cfam->in[att_num]->ndesc) {
      printf("error j %d: index %d not legal for %s\n", 
	     yylineno, yypvt[-0].intV, cfam->in[att_num]->name);
      exit(0);
    }
    else
      att[att_num] = yypvt[-0].intV;
    att_num++;
  }
} break;
case 331:
# line 1195 "cmd.y"
{ strcpy(yyval.strV,yypvt[-0].strV); } break;
case 332:
# line 1196 "cmd.y"
{ Str255 s; sprintf(s, "%lf", (int)yypvt[-0].doubV); strcpy(yyval.strV,s);} break;
case 333:
# line 1197 "cmd.y"
{ Str255 s; sprintf(s, "%d", (int)yypvt[-0].intV); strcpy(yyval.strV,s);} break;
case 334:
# line 1198 "cmd.y"
{ strcpy(yyval.strV,"?"); } break;
case 335:
# line 1201 "cmd.y"
{ yyval.doubV = yypvt[-0].doubV; } break;
case 336:
# line 1202 "cmd.y"
{ yyval.doubV = yypvt[-0].intV; } break;
case 337:
# line 1205 "cmd.y"
{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else {
    if (att!=NULL) free(att);
    att = c_vector(cfam->n_in);
  }
} break;
case 338:
# line 1215 "cmd.y"
{ yyval.erV = er_table; } break;
case 339:
# line 1216 "cmd.y"
{ yyval.erV = er_list; } break;
case 340:
# line 1217 "cmd.y"
{ yyval.erV = er_tree; } break;
	}
	goto yystack;		/* reset registers in driver code */
}
