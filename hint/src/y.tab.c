/* original parser id follows */
/* yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93" */
/* (use YYMAJOR/YYMINOR for ifdefs dependent on parser version) */

#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYPATCH 20140715

#define YYEMPTY        (-1)
#define yyclearin      (yychar = YYEMPTY)
#define yyerrok        (yyerrflag = 0)
#define YYRECOVERING() (yyerrflag != 0)
#define YYENOMEM       (-2)
#define YYEOF          0
#define YYPREFIX "yy"

#define YYPURE 0

#line 6 "cmd.y"
#include <stdio.h>
#include <math.h>
#include <sys/types.h>
#include <sys/times.h>
#define GL extern
#include "sds.h"

extern yylineno;		/* line number in screen def. source */
char *att = NULL;		/* attrib of property, used to enter rules */
int att_num = 0;

list_of_vars *tmp_vars=NULL;

#line 21 "cmd.y"
#ifdef YYSTYPE
#undef  YYSTYPE_IS_DECLARED
#define YYSTYPE_IS_DECLARED 1
#endif
#ifndef YYSTYPE_IS_DECLARED
#define YYSTYPE_IS_DECLARED 1
typedef union {
  int intV;
  double doubV;
  char chV;
  Str255 strV;
  char *chpV;
  list_of_vars *varL;
  list_of_str *strL;
  list_of_num *numL;
  list_of_q *strQ;
  fa_type faV;
  ga_error_type gaeV;
  ga_policy_type gapV;
  eval_method_type evalV;
  coloring_type colV;
  er_type erV;
} YYSTYPE;
#endif /* !YYSTYPE_IS_DECLARED */
#line 60 "y.tab.c"

/* compatibility with bison */
#ifdef YYPARSE_PARAM
/* compatibility with FreeBSD */
# ifdef YYPARSE_PARAM_TYPE
#  define YYPARSE_DECL() yyparse(YYPARSE_PARAM_TYPE YYPARSE_PARAM)
# else
#  define YYPARSE_DECL() yyparse(void *YYPARSE_PARAM)
# endif
#else
# define YYPARSE_DECL() yyparse(void)
#endif

/* Parameters sent to lex. */
#ifdef YYLEX_PARAM
# define YYLEX_DECL() yylex(void *YYLEX_PARAM)
# define YYLEX yylex(YYLEX_PARAM)
#else
# define YYLEX_DECL() yylex(void)
# define YYLEX yylex()
#endif

/* Parameters sent to yyerror. */
#ifndef YYERROR_DECL
#define YYERROR_DECL() yyerror(const char *s)
#endif
#ifndef YYERROR_CALL
#define YYERROR_CALL(msg) yyerror(msg)
#endif

extern int YYPARSE_DECL();

#define ADD 257
#define AND 258
#define VAR 259
#define QUIT 260
#define DEL 261
#define LIST 262
#define VARS 263
#define DEPENDS 264
#define ON 265
#define IN 266
#define IS 267
#define STRUCTURE 268
#define OF 269
#define FAM 270
#define FOR 271
#define RULE 272
#define ALL 273
#define DESCRIPTIONS 274
#define SET 275
#define CURRENT 276
#define SHOW 277
#define OPT 278
#define NODE 279
#define DERIVE 280
#define SEL 281
#define LOAD 282
#define UNDEF 283
#define TEST 284
#define EVALUATE 285
#define EXPECT 286
#define COMMENT 287
#define LEARN 288
#define STAT 289
#define GA 290
#define POPULATION 291
#define POINTS 292
#define PLOT 293
#define MAN 294
#define WAIT 295
#define DEBUG 296
#define ITERATIONS 297
#define LEX 298
#define PRINT 299
#define FREQ 300
#define ERROR 301
#define MAX 302
#define YECHO 303
#define SAVE 304
#define IMP 305
#define WEIGHT 306
#define MIN 307
#define MULT 308
#define INFORMATIVITY 309
#define GAABS 310
#define YES 311
#define NO 312
#define PREFER 313
#define MUTATION 314
#define POLICY 315
#define CUSTOM 316
#define OR 317
#define LSQR 318
#define RESET 319
#define CROSSOVER 320
#define USAGE 321
#define NORM 322
#define WIDTH 323
#define TABLE 324
#define SPLIT 325
#define DECOMPOSE 326
#define REDO 327
#define GAMMA 328
#define TS 329
#define USING 330
#define CL 331
#define SIGM 332
#define KNN 333
#define COLOR 334
#define COMPUTE 335
#define ONE 336
#define COMPOSE 337
#define HEURISTIC 338
#define COPY 339
#define TO 340
#define QUALITATIVE 341
#define FROM 342
#define QUANTITATIVE 343
#define COMPARE 344
#define STEP 345
#define REPEAT 346
#define YLOG 347
#define GR 348
#define GINI 349
#define RELIEFF 350
#define FUZZY 351
#define CRISP 352
#define PREFIX 353
#define JOIN 354
#define INTERVAL 355
#define INSTANCE 356
#define TREE 357
#define DM 358
#define PJOIN 359
#define FJOIN 360
#define SURE 361
#define NEED 362
#define REDUNDANT 363
#define VECT 364
#define SAME 365
#define GROUP 366
#define ANALYZE 367
#define NAMES 368
#define WRITE 369
#define DIFFERENT 370
#define SOFT 371
#define MNUMBER 372
#define DOT 373
#define COUNT 374
#define LOCAL 375
#define GLOBAL 376
#define SDTIC 377
#define DFC 378
#define DTIC 379
#define CM 380
#define MERGE 381
#define PAIRS 382
#define LAPLACE 383
#define CLUSTER 384
#define NOISE 385
#define SEED 386
#define DONTCARE 387
#define DONTKNOW 388
#define APRIORY 389
#define DISTRIBUTION 390
#define CV 391
#define SAMPLE 392
#define SORT 393
#define MDL 394
#define LEAF 395
#define NOD 396
#define DUPLICATE 397
#define EXPAND 398
#define NUM 399
#define INUM 400
#define STRING 401
#define FNAME 402
#define ID 403
#define YYERRCODE 256
typedef short YYINT;
static const YYINT yylhs[] = {                           -1,
    0,    0,    0,    0,    0,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   11,   11,
    9,    9,    9,   13,   13,   13,   14,   14,   14,   14,
   10,   10,   10,   10,   10,   10,   12,   12,   12,   21,
   21,   26,    1,    2,    2,    2,    2,    2,    2,    2,
    2,    3,    4,    4,   27,   27,   27,   27,   28,   28,
   28,   23,   23,    5,    6,    6,    7,    7,    8,    8,
   24,   24,   15,   15,   16,   25,   25,   29,   29,   30,
   18,   18,   18,   18,   19,   19,   22,   17,   17,   17,
};
static const YYINT yylen[] = {                            2,
    3,    2,    2,    1,    2,    0,    3,    5,    4,    3,
    2,    2,    6,    2,    2,    3,    2,    2,    4,    3,
    3,    5,    5,    3,   11,   11,   13,    7,    6,    6,
    2,    2,    3,    8,    3,    5,    2,    1,    1,    2,
    2,    2,    5,    3,    8,    4,    4,    4,    8,    3,
    9,    3,    5,    2,    4,    5,    2,    2,    3,    3,
    2,    3,    2,    5,    5,    3,    3,    8,    9,    6,
    5,    3,    2,    2,    3,    3,    3,    3,    3,    4,
    4,   12,    3,    3,    3,    3,    3,    3,    3,    3,
    3,    5,    5,    9,    3,    3,    4,    4,    4,    4,
    5,    5,    2,    2,    2,    2,    2,    4,    4,    4,
    4,    3,    2,    2,    2,    4,    4,    4,    4,    4,
    4,    2,    3,    3,    3,    3,    3,    5,    3,    4,
    2,    4,    2,    4,    4,    6,    4,    2,    6,    2,
    2,    3,    9,    3,    4,    4,    5,    4,    8,    8,
    5,   10,    4,    4,    6,    6,    6,    5,    6,    3,
    4,    6,    6,    6,    6,    6,    6,    6,    6,    6,
    5,    4,    4,    4,    3,    2,    5,    3,    5,    3,
    3,    2,    2,    3,    7,    6,    8,    6,    8,    1,
    4,    4,    4,    4,    3,    4,    4,    2,    2,    2,
    2,    2,    4,    3,    2,    2,    3,    3,    3,    5,
    3,    2,    2,    3,    2,    3,    1,    2,    6,    2,
    1,    3,    4,    4,    5,    3,    3,    3,    2,    2,
    2,    2,    2,    2,    3,    2,    5,    5,    8,    3,
    3,    2,    3,    5,    3,    3,    3,    3,    2,    4,
    5,    5,    5,    5,    2,    1,    2,    2,    2,    2,
    2,    3,    3,    2,    2,    2,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    2,    2,    1,    1,    1,    1,    3,
    1,    1,    1,    3,    3,    3,    3,    1,    1,    1,
    1,    1,    3,    1,    1,    1,    1,    0,    1,    1,
    0,    1,    0,    1,    3,    1,    3,    1,    3,    3,
    3,    1,    3,    1,    1,    3,    1,    3,    1,    1,
    1,    1,    1,    1,    1,    1,    0,    1,    1,    1,
};
static const YYINT yydefred[] = {                         0,
    0,    0,    0,  268,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    4,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  267,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  190,    0,    0,   39,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  221,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    5,    0,    0,    0,    0,    0,    0,    0,
    0,   11,    0,   12,   14,    0,   40,    0,   31,    0,
    0,  199,    0,    0,  202,  200,   73,    0,    0,    0,
  337,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  229,  230,    0,  233,    0,    0,    0,    0,    0,    0,
    0,  316,    0,    0,    0,    0,    0,  255,    0,    0,
  242,  140,  215,  212,    0,    0,    0,    0,  335,  336,
    0,  141,    0,    0,    0,    0,    0,    0,    0,  176,
    0,   42,   32,    0,  138,  264,  259,  257,  258,  265,
    0,    0,    0,    0,  249,    0,   15,  260,  261,    0,
   57,   58,    0,    0,    0,    0,    0,    0,    0,    0,
  182,    0,  183,    0,    0,    0,   17,   18,    0,    0,
  103,  106,  105,  104,  107,  266,    0,    0,    0,    0,
    0,    0,  205,  206,    0,  198,    0,    0,    0,    0,
    0,    0,    0,    0,  114,  113,  115,  220,    0,    0,
  232,   41,    0,    0,    0,    0,    0,    0,    3,    0,
    0,  307,  305,  306,    0,    0,    0,    2,    7,  262,
   10,    0,   52,    0,  124,   66,    0,    0,    0,    0,
    0,  292,    0,  291,    0,   35,  123,   67,    0,   79,
    0,    0,  337,    0,    0,  300,  301,  298,  299,    0,
    0,  339,  338,  340,   33,  125,  274,  275,  276,  142,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   16,    0,  281,    0,  286,  283,
  160,    0,    0,    0,    0,   87,    0,    0,   88,   83,
   84,   89,   86,   90,   85,    0,  209,  280,  277,  279,
  278,  204,  195,    0,    0,    0,  269,  270,  112,  211,
  226,    0,  240,  241,  227,  228,   50,    0,    0,   44,
  263,    0,    0,    0,    0,    0,    0,    0,  126,    0,
    0,    0,    0,    0,    0,   59,  214,    0,    0,    0,
    0,  175,    0,    0,    0,    0,  178,  180,  245,    0,
  247,  246,  248,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  184,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   75,   77,   76,   78,    0,    0,
  207,    0,    0,    0,    0,    0,  208,   72,   21,   20,
   60,  216,   62,    0,    0,    0,  332,  333,  331,  334,
    0,  127,  129,    0,    1,    0,  295,  296,  294,  297,
   24,    0,    0,    0,   97,   99,   98,  100,    0,    9,
    0,    0,  145,  137,    0,    0,    0,    0,   47,   46,
   48,  272,  271,  273,  161,    0,    0,    0,    0,  153,
  154,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  108,  111,  110,  109,  285,  284,    0,   81,  197,
  196,  193,  121,  194,    0,    0,  191,  192,   80,  224,
    0,    0,    0,    0,    0,    0,  146,  135,  134,    0,
  315,    0,    0,    0,  148,    0,    0,    0,  132,  130,
  172,    0,  174,  173,    0,    0,    0,   55,    0,    0,
    0,    0,  116,    0,  118,  117,  119,  120,    0,    0,
    0,   19,    0,    0,    0,    0,    0,  203,    0,    0,
    0,    0,    0,  250,    0,    0,    0,    0,    0,    0,
    0,    0,  318,    0,    0,    8,   53,  102,  290,   36,
    0,    0,    0,    0,  312,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  287,  289,  288,  171,    0,
    0,    0,  158,    0,   93,    0,  225,  238,  237,    0,
    0,    0,    0,   43,  147,  244,    0,  101,    0,  177,
    0,  179,   65,   56,    0,    0,    0,    0,    0,   64,
    0,   71,    0,    0,    0,    0,    0,    0,  252,  253,
  254,  251,    0,    0,    0,  151,   23,    0,    0,  128,
    0,   22,  210,  139,    0,    0,    0,    0,  324,  325,
    0,  155,  168,  169,  170,  157,  156,  162,  163,  164,
  165,  166,  167,  159,    0,    0,    0,   29,  136,    0,
  219,   30,    0,    0,    0,    0,   70,    0,    0,  186,
    0,    0,  304,    0,    0,  188,   13,    0,    0,  320,
  319,  317,    0,    0,  330,    0,    0,  329,  309,  310,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  185,    0,    0,   28,    0,    0,    0,    0,    0,   34,
   45,    0,    0,    0,  323,    0,   49,    0,  150,  149,
    0,  239,    0,    0,   68,  187,  303,    0,  189,    0,
    0,    0,   51,  328,   94,    0,   69,    0,  143,    0,
    0,    0,  152,    0,    0,    0,   25,    0,   26,   82,
    0,   27,
};
static const YYINT yydgoto[] = {                         67,
   68,   69,  681,  682,  133,  134,  562,  563,  465,  311,
  339,  589,  290,  333,  648,  649,  285,  650,   71,   72,
  263,  274,  576,  651,  696,  264,  245,  701,  697,  698,
};
static const YYINT yysindex[] = {                       165,
   96, -135, -174,    0, -106, -188, -200,  -28,  436,  -65,
  -90, -222, -230, -204,  -41, -141, -285, -142,    0, -197,
   22, -191, -133,  -85, -130, -213, -126, -124,  -94, -183,
 -123,  168,    0,  -23,  -98, -216,  -83,  -81, -229,  -80,
  -77,   42, -277,  -76,  -77,    0,  -11,   -3,    0,  -71,
   -2, -209,  -70, -185,  -73,  -66,  -63, -193,    0, -175,
   46,   66,    0,    0,  -33,    0,  319,   76,  117,    3,
  308,  341,    0,  -49,  -43,  -27,  236,  -32,  -26,  -25,
 -207,    0,  -20,    0,    0,  -18,    0,   92,    0,   97,
  -17,    0,   51,  -15,    0,    0,    0,  108,  109,   60,
    0,  326,  -53,  328, -220,  -12,  -51,  437, -107,   -8,
  -24,  110, -179,  -88, -224, -116,  121,  -30, -175,  -59,
    0,    0,   16,    0,    9, -175,  136,   17, -159,  146,
   99,    0,  157,  385,   28,   29,   34,    0,   31,   94,
    0,    0,    0,    0,   35,   36, -175,   38,    0,    0,
 -175,    0,  173,  394, -236,   54,  188,  191,  192,    0,
 -240,    0,    0,  163,    0,    0,    0,    0,    0,    0,
   62, -232,   63,   64,    0,  410,    0,    0,    0,  151,
    0,    0,  133,  438,   73,   77,   78,   79,   80,   82,
    0,   83,    0,  137,  147,  451,    0,    0,   86,  153,
    0,    0,    0,    0,    0,    0,  -35,   91,   93,  155,
  -95,    6,    0,    0,   98,    0,  100,  102,  104, -247,
  101,  107,  111,  120,    0,    0,    0,    0,  125,  113,
    0,    0, -175,  246,  128,  177,  -47, -104,    0,  526,
  414,    0,    0,    0,  -42,  -47,  156,    0,    0,    0,
    0,  -20,    0,  -53,    0,    0,  135,  145,  149,  150,
  269,    0,    5,    0,  278,    0,    0,    0,  152,    0,
  -91,  154,    0,  427,  -97,    0,    0,    0,    0,  513,
  -56,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  264, -157,  159,  160,  266,  275,  -79,  508,  -44,  509,
  -30,  -30,  -30,  -30,    0,  535,    0,  536,    0,    0,
    0,  273,  -30, -211,  175,    0,  182,  178,    0,    0,
    0,    0,    0,    0,    0, -221,    0,    0,    0,    0,
    0,    0,    0,  -30,  -30,  184,    0,    0,    0,    0,
    0, -255,    0,    0,    0,    0,    0,  313, -175,    0,
    0,  183,  185,  -77,  187,  -93,  189,  314,    0,  245,
  265,  195,  339,  340, -175,    0,    0,  210,  218,  215,
  348,    0,  217,  222,  223,  297,    0,    0,    0,  303,
    0,    0,    0,  230,  359,  228, -181,  233,  369,  235,
  237,  239,  240,    0,  238,  312,  373,  243,  323,  -77,
  247,  376,  377,  250,    0,    0,    0,    0,  -77,  248,
    0,  321,  324,  325,  249,  327,    0,    0,    0,    0,
    0,    0,    0,  531,  392,  344,    0,    0,    0,    0,
  329,    0,    0,  -84,    0,  -53,    0,    0,    0,    0,
    0,  330,   26,  630,    0,    0,    0,    0,  -77,    0,
  -20,  274,    0,    0,  -53, -122,  549,  672,    0,    0,
    0,    0,    0,    0,    0,  624,  626,  629,  631,    0,
    0,  634,  641,  642,  643,  645, -119,  646,  648,  649,
  292,    0,    0,    0,    0,    0,    0,  652,    0,    0,
    0,    0,    0,    0,  315,  316,    0,    0,    0,    0,
  419,  320,  331,  382,  387,  397,    0,    0,    0,  -53,
    0,  336,  338,  333,    0,  343,  -77,  399,    0,    0,
    0,  342,    0,    0,  400,  345,  346,    0,  347,  488,
  350,  423,    0,  -77,    0,    0,    0,    0,  415,  351,
  432,    0,  355,  490,  421,  640,  361,    0,  496,  426,
  364,  365,  366,    0,  368,  -53,   32,  370,  -47,  725,
  728,   37,    0,  651,  374,    0,    0,    0,    0,    0,
  653,  656,  381,  672,    0,  -47,  384,  -30,  -30,  -30,
  386,  388,  389,  390,  391,    0,    0,    0,    0,  393,
  396,  398,    0,  401,    0,  523,    0,    0,    0,  428,
  430,  395,  666,    0,    0,    0,  453,    0, -175,    0,
  402,    0,    0,    0,  403,  456,  404,  541,  406,    0,
  407,    0,  408,  409, -175,  678,  411,  412,    0,    0,
    0,    0,  677,  405,  417,    0,    0,  418,  420,    0,
  -84,    0,    0,    0,  -53,  742,  413,   88,    0,    0,
  808,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  422,  505,  506,    0,    0,  433,
    0,    0,  501,  431,  480,  -77,    0,  493,  495,    0,
  711,  117,    0,  672,  497,    0,    0,  794,  795,    0,
    0,    0,  715,  439,    0,  831,   88,    0,    0,    0,
  -47,  -47,  718,  504,  442,  443,  502,  448,  591,  447,
    0,  449,  450,    0, -175,  -53,  452,  455,  457,    0,
    0,  413,  726,  413,    0,   88,    0,  458,    0,    0,
  460,    0,  454,  602,    0,    0,    0,  736,    0,  818,
  819,   88,    0,    0,    0,  592,    0,  462,    0,  467,
  468,  599,    0,  828,  142,  469,    0,  471,    0,    0,
  830,    0,
};
static const YYINT yyrindex[] = {                       863,
    0,    0,    0,    0,    0,  864,    0,    0,    0,  865,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  866,    0,    0,
    0,    0,   -6,   -1,    1,    8,  863,    0,  -34,    0,
    0,    0,    0,    0,    0,    0,    0,  867,    0,    0,
    0,    0,    0,    0,    0,  868,    0,    0,    0,  869,
  870,    0,  871,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  872,    0,  873,  874,    0,    0,    0,    0,
    0,    0,  875,   14,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  876,    0,  877,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  878,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  879,
    0,    0,  880,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  881,    0,    0,    0,    0,    0,    0,    0,  882,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  883,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  884,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  885,    0,    0,    0,    0,    0,  886,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  887,    0,  888,  889,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  -36,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  890,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  503,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  891,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   13,    0,    0,
  777,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  -92,    0,  -36,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  777,   -5,    0,    0,    0,
    0,  779,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  779,    0,    0,    0,   15,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   -4,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,
};
static const YYINT yygindex[] = {                         0,
 -100,    0,    0,    0,  -19,    0,    0,  267,    0,    0,
 -206,    0,    0,    0,  203,  205,    0,    2,  -16,  840,
  657,  637, -463,    0,    0,  461,  229, -549,  193,  190,
};
#define YYTABLESIZE 915
static const YYINT yytable[] = {                        151,
  160,   70,  280,  300,  327,  326,  293,  254,  301,  279,
  298,  103,  310,  237,  184,  430,   83,  299,  434,  196,
  440,  207,  322,  314,  321,  212,  313,  238,  308,  510,
  335,  455,  302,  380,  370,  336,  495,  300,  199,  135,
  327,  282,  301,  231,  298,  500,  209,  136,  451,  129,
  328,  299,  300,  329,  171,  194,  300,  301,  172,  298,
  173,  301,  217,  298,  174,  330,  299,  139,   70,  451,
  299,  635,  155,  156,   84,  311,  157,  311,  162,   85,
  641,   86,  163,   87,   88,   89,  222,  531,  180,   90,
  293,  228,  415,  223,  482,  483,  484,  485,  164,  337,
  338,  257,  340,  283,  313,   73,  489,  491,  158,  349,
  647,  352,  467,  331,  152,  376,  468,  153,  496,  327,
  326,  210,  634,   74,  501,  137,  242,  497,  498,  450,
  365,  699,  130,  131,  367,   91,  284,  322,  586,  321,
  258,  259,  260,  143,  572,   92,  700,  724,  469,  573,
  566,  140,   76,  444,  314,  416,   77,  159,  218,  144,
  243,  640,  377,  219,  353,   78,  371,   93,   94,   95,
  381,   79,  138,  200,  532,  244,  332,   96,   75,  508,
  132,  454,  149,  150,  145,  758,  195,  703,  167,  175,
  474,  490,  724,  220,  475,  261,  587,  588,  141,  168,
   97,  301,   99,  229,  169,  132,  230,  315,  334,  224,
  127,  165,  316,  405,   98,  181,  423,   80,  335,  182,
  716,  146,  400,  149,  150,  478,  476,   66,  201,  479,
  234,  293,  723,  401,  759,  235,  142,  317,  431,  147,
  302,  303,  304,  100,  318,  462,  178,  441,  179,  341,
  463,  464,  406,  407,  408,  148,   81,  149,  150,  300,
  154,  480,  128,  409,  301,  166,  298,  202,  203,  204,
  170,  314,  176,  299,  410,  149,  150,  306,  177,  183,
  337,  338,  314,  319,  314,  307,  320,  321,  322,  323,
  324,  325,  161,  308,  432,  101,   82,  309,  433,  287,
  288,  459,  192,  289,  193,  460,  308,  308,  236,  509,
  208,  326,  342,  205,  560,  343,  344,  232,  561,  197,
  206,  198,  213,  345,  346,  132,  211,  215,  221,  225,
  214,  216,  503,  332,  506,  564,  226,  233,  333,  227,
  331,  241,  246,  314,  247,  276,  277,  334,  518,  278,
  248,  427,  428,  249,  571,  429,  437,  438,  252,  250,
  439,  266,  313,  313,  308,  308,  313,  253,  308,  267,
  102,  653,  654,  655,  269,  251,  255,  256,  271,  272,
  544,   66,  262,  273,  265,  268,  275,  270,  281,  549,
  286,  305,  300,  300,  311,  311,  300,  301,  301,  298,
  298,  301,  312,  298,  336,  350,  299,  299,  348,  603,
  299,  311,  311,  311,  311,  311,  354,  311,  347,  351,
    1,    2,  355,    3,    4,    5,    6,  356,  357,  568,
  358,  359,  360,  361,    7,  362,    8,  363,  364,    9,
  366,   10,   11,  368,   12,   13,   14,   15,   16,   17,
   18,   19,   20,   21,  369,  633,  372,   22,  373,   23,
   24,  374,  375,  378,  379,  382,  383,   25,   26,   27,
  384,  385,  386,   28,  387,  388,  185,   29,  395,  389,
  390,  391,  392,   30,  393,  394,  396,  397,  398,   31,
   32,  186,  399,  402,  404,  403,  411,  608,   33,  417,
   34,   35,  412,   36,  413,   37,  414,   38,   39,  418,
  424,   40,  422,  419,  618,  187,  188,  189,   41,   42,
   43,   44,  420,   45,   46,   47,   48,  421,   49,   50,
  425,   51,  426,   52,   53,  435,  436,  445,   54,  449,
  442,   55,   56,   57,  693,   58,   59,  446,  452,  458,
   60,  447,  448,  461,  453,  466,  456,   61,  470,  471,
  637,  190,   62,   63,   64,  472,  473,   65,  477,  481,
  191,  486,  487,  488,  492,    2,  494,    3,    4,    5,
    6,  493,  499,  502,  512,  504,  513,  505,    7,  507,
    8,  511,  671,    9,  514,   10,   11,  515,   12,   13,
   14,   15,   16,   17,   18,  239,   20,   21,  683,  516,
  517,   22,  519,   23,   24,  738,  520,  521,  522,  523,
  526,   25,   26,   27,  524,  525,  527,   28,  528,  529,
  530,   29,  533,  534,  535,  540,  536,   30,  537,  538,
  539,  541,  546,   31,   32,  542,  543,  547,  548,  545,
  550,  554,   33,  556,   34,   35,  711,   36,  557,   37,
  551,   38,   39,  552,  553,   40,  555,  558,  559,  565,
  567,  574,   41,   42,   43,   44,  570,   45,   46,   47,
   48,  575,   49,   50,  577,   51,  578,   52,   53,  579,
  593,  580,   54,  104,  581,   55,   56,   57,  737,   58,
   59,  582,  583,  584,   60,  585,  590,  105,  591,  592,
  291,   61,  594,  106,  595,  596,   62,   63,   64,  597,
  107,   65,  598,  600,  292,  108,  602,  293,  601,  611,
  599,  109,  606,  294,  110,  295,  111,  112,  604,  113,
  605,  607,  296,  609,  610,  615,  617,  612,  613,  614,
  297,  298,  616,  620,  619,  621,  299,  622,  623,  300,
  624,  114,  625,  626,  627,  628,  629,  630,  631,  115,
  632,  638,  636,  116,  639,  642,  643,  644,  645,  646,
  665,  117,  652,  666,  656,  667,  657,  658,  659,  660,
  669,  661,  670,  118,  662,  674,  663,  668,  676,  664,
  684,  687,  694,  688,  672,  673,  675,  119,  677,  678,
  679,  680,  695,  685,  686,  689,  690,  702,  691,  710,
  120,  704,  121,  122,  123,  124,  125,  126,  705,  706,
  708,  707,  712,  709,  713,  714,  717,  718,  719,  720,
  722,  721,  727,  728,  729,  730,  731,  732,  733,  734,
  743,  735,  736,  740,  739,  741,  747,  745,  746,  748,
  749,  750,  751,  752,  753,  754,  755,  756,  757,  761,
  762,  760,    6,   38,  256,  217,   54,   37,  122,   63,
  201,  231,  234,  236,  133,  213,  131,   74,  218,   61,
   96,  144,  282,   91,  222,  235,  243,  181,   95,  223,
   92,  313,  313,  312,  726,  725,  240,  692,  443,  457,
  715,  569,    0,  744,  742,
};
static const YYINT yycheck[] = {                         16,
   20,    0,  103,   10,   10,   10,   41,   40,   10,   63,
   10,   40,   37,   47,   31,   63,  123,   10,  123,   36,
   63,   41,   10,   10,   10,   45,   63,   61,   63,  123,
   37,  123,  125,  266,  271,   37,  258,   44,  268,  270,
  265,  262,   44,   60,   44,  301,  324,  278,   44,  272,
  275,   44,   59,  278,  268,  272,   63,   59,  272,   59,
  274,   63,  272,   63,  278,  290,   59,  272,   67,   44,
   63,   40,  270,  271,  263,   63,  274,   63,  270,  268,
   44,  270,  274,  272,  273,  274,  272,  269,  272,  278,
  125,  285,  340,  279,  301,  302,  303,  304,  290,  311,
  312,  309,  119,  324,  284,   10,  313,  314,  306,  126,
  574,  271,  270,  338,  400,  356,  274,  403,  340,  125,
  125,  399,   91,  259,  380,  356,   10,  334,  335,  125,
  147,   44,  355,  356,  151,  324,  357,  125,  258,  125,
  348,  349,  350,  285,  267,  334,   59,  697,  306,  272,
  125,  356,  259,  254,  334,  403,  263,  355,  368,  301,
   44,  125,  403,  373,  324,  272,  403,  356,  357,  358,
  403,  278,  403,  403,  356,   59,  401,  366,  353,  273,
  403,  273,  399,  400,  326,   44,  403,  651,  274,  403,
  270,  403,  742,  403,  274,  403,  316,  317,  403,  285,
  389,  309,  403,  397,  290,  403,  400,  296,  325,  395,
  276,  403,  301,  309,  403,  399,  233,  324,  335,  403,
  684,  363,  258,  399,  400,  270,  306,   63,  309,  274,
  264,  266,  696,  269,   93,  269,  278,  326,  237,  381,
  348,  349,  350,  272,  333,  302,  341,  246,  343,  309,
  307,  308,  348,  349,  350,  397,  363,  399,  400,  266,
  403,  306,  353,  258,  266,  399,  266,  348,  349,  350,
  401,  258,  399,  266,  269,  399,  400,  302,  403,  403,
  311,  312,  269,  372,  271,  310,  375,  376,  377,  378,
  379,  380,  271,  318,  399,  324,  403,  322,  403,  351,
  352,  399,  326,  355,  403,  403,  399,  400,  342,  403,
  269,  400,  372,  394,  399,  375,  376,  272,  403,  403,
  401,  403,  334,  383,  384,  403,  403,  399,  399,  403,
  334,  334,  349,  340,  354,  436,  403,  272,  340,  403,
  340,  266,  340,  330,   37,  399,  400,  340,  365,  403,
   10,  399,  400,  403,  455,  403,  399,  400,  123,  403,
  403,  270,  399,  400,  399,  400,  403,  400,  403,  273,
  399,  578,  579,  580,  324,  403,  403,  403,  271,  271,
  400,   63,  403,  324,  403,  403,   61,  403,   61,  409,
  403,  400,  399,  400,  400,  400,  403,  399,  400,  399,
  400,  403,  293,  403,  284,  270,  399,  400,  400,  510,
  403,  399,  400,  399,  400,  403,  271,  403,  403,  403,
  256,  257,  324,  259,  260,  261,  262,  271,   44,  449,
  403,  403,  399,  403,  270,  342,  272,  403,  403,  275,
  403,  277,  278,  271,  280,  281,  282,  283,  284,  285,
  286,  287,  288,  289,   61,  556,  403,  293,  271,  295,
  296,  271,  271,  301,  403,  403,  403,  303,  304,  305,
   61,  321,  340,  309,   37,  403,  309,  313,  342,  403,
  403,  403,  403,  319,  403,  403,  340,   37,  403,  325,
  326,  324,  340,  403,  340,  403,  399,  517,  334,  399,
  336,  337,  403,  339,  403,  341,  403,  343,  344,  403,
  265,  347,  400,  403,  534,  348,  349,  350,  354,  355,
  356,  357,  403,  359,  360,  361,  362,  403,  364,  365,
  403,  367,  356,  369,  370,   10,  123,  403,  374,  271,
  385,  377,  378,  379,  645,  381,  382,  403,  271,  123,
  386,  403,  403,   41,  403,  292,  403,  393,  400,  400,
  559,  394,  398,  399,  400,  300,  292,  403,   61,   61,
  403,   37,   37,  301,  400,  257,  399,  259,  260,  261,
  262,  400,  399,  271,  271,  403,  342,  403,  270,  403,
  272,  403,  609,  275,  330,  277,  278,  403,  280,  281,
  282,  283,  284,  285,  286,  287,  288,  289,  625,  271,
  271,  293,  403,  295,  296,  716,  399,  403,  271,  403,
  324,  303,  304,  305,  403,  403,  324,  309,  399,  271,
  403,  313,  400,  265,  400,  324,  400,  319,  400,  400,
  403,  269,  267,  325,  326,  403,  324,  271,  399,  403,
  403,  403,  334,  123,  336,  337,  676,  339,  267,  341,
  340,  343,  344,  340,  340,  347,  340,  324,  340,  340,
   41,  123,  354,  355,  356,  357,  403,  359,  360,  361,
  362,   10,  364,  365,   61,  367,   61,  369,  370,   61,
  399,   61,  374,  258,   61,  377,  378,  379,  715,  381,
  382,   61,   61,   61,  386,   61,   61,  272,   61,   61,
  274,  393,   61,  278,  400,  400,  398,  399,  400,  301,
  285,  403,  403,  342,  288,  290,  330,  291,  342,  330,
  400,  296,  400,  297,  299,  299,  301,  302,  403,  304,
  403,  399,  306,  345,  403,  258,  324,  403,  403,  403,
  314,  315,  403,  403,  340,  324,  320,  403,  269,  323,
  340,  326,  123,  403,  269,  340,  403,  403,  403,  334,
  403,   47,  403,  338,   47,  125,  403,  125,  123,  399,
  258,  346,  399,  356,  399,  356,  399,  399,  399,  399,
  125,  399,  340,  358,  399,  340,  399,  403,  258,  399,
  123,  125,   61,  399,  403,  403,  403,  372,  403,  403,
  403,  403,  400,  403,  403,  399,  399,   10,  399,  340,
  385,  400,  387,  388,  389,  390,  391,  392,  324,  324,
  330,  399,  340,  403,  340,  125,  340,   44,   44,  125,
   10,  403,  125,  340,  403,  403,  345,  400,  258,  403,
  125,  403,  403,  399,  403,  399,  403,  400,  399,  258,
  125,   44,   44,  272,  403,  399,  399,  269,   41,  399,
   41,  403,   10,   10,   10,   10,   10,   10,   10,   10,
   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
   10,  125,  400,  125,  702,  701,   67,  641,  252,  273,
  682,  451,   -1,  724,  722,
};
#define YYFINAL 67
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 403
#define YYUNDFTOKEN 436
#define YYTRANSLATE(a) ((a) > YYMAXTOKEN ? YYUNDFTOKEN : (a))
#if YYDEBUG
static const char *const yyname[] = {

"end-of-file",0,0,0,0,0,0,0,0,0,"'\\n'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,"'%'",0,0,"'('","')'",0,0,"','",0,0,"'/'",0,0,0,0,0,0,0,0,0,0,0,
"';'",0,"'='",0,"'?'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
"'['",0,"']'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'{'",0,
"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,"ADD","AND","VAR","QUIT","DEL","LIST","VARS",
"DEPENDS","ON","IN","IS","STRUCTURE","OF","FAM","FOR","RULE","ALL",
"DESCRIPTIONS","SET","CURRENT","SHOW","OPT","NODE","DERIVE","SEL","LOAD",
"UNDEF","TEST","EVALUATE","EXPECT","COMMENT","LEARN","STAT","GA","POPULATION",
"POINTS","PLOT","MAN","WAIT","DEBUG","ITERATIONS","LEX","PRINT","FREQ","ERROR",
"MAX","YECHO","SAVE","IMP","WEIGHT","MIN","MULT","INFORMATIVITY","GAABS","YES",
"NO","PREFER","MUTATION","POLICY","CUSTOM","OR","LSQR","RESET","CROSSOVER",
"USAGE","NORM","WIDTH","TABLE","SPLIT","DECOMPOSE","REDO","GAMMA","TS","USING",
"CL","SIGM","KNN","COLOR","COMPUTE","ONE","COMPOSE","HEURISTIC","COPY","TO",
"QUALITATIVE","FROM","QUANTITATIVE","COMPARE","STEP","REPEAT","YLOG","GR",
"GINI","RELIEFF","FUZZY","CRISP","PREFIX","JOIN","INTERVAL","INSTANCE","TREE",
"DM","PJOIN","FJOIN","SURE","NEED","REDUNDANT","VECT","SAME","GROUP","ANALYZE",
"NAMES","WRITE","DIFFERENT","SOFT","MNUMBER","DOT","COUNT","LOCAL","GLOBAL",
"SDTIC","DFC","DTIC","CM","MERGE","PAIRS","LAPLACE","CLUSTER","NOISE","SEED",
"DONTCARE","DONTKNOW","APRIORY","DISTRIBUTION","CV","SAMPLE","SORT","MDL",
"LEAF","NOD","DUPLICATE","EXPAND","NUM","INUM","STRING","FNAME","ID",0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"illegal-symbol",
};
static const char *const yyrule[] = {
"$accept : commands",
"commands : commands command '\\n'",
"commands : command '\\n'",
"commands : commands COMMENT",
"commands : COMMENT",
"commands : error '\\n'",
"command :",
"command : ADD VAR ID",
"command : DEL VARS '{' new_vars '}'",
"command : DEL '{' new_vars '}'",
"command : DEL VAR ID",
"command : DEL ID",
"command : LIST VARS",
"command : ID DEPENDS ON '{' str_list '}'",
"command : LIST STRUCTURE",
"command : INFORMATIVITY ID",
"command : SET PRINT INUM",
"command : QUALITATIVE ID",
"command : QUANTITATIVE ID",
"command : COMPARE STRUCTURE ID ID",
"command : COUNT LEAF ID",
"command : COUNT NODE ID",
"command : str_list IN '{' str_list '}'",
"command : ID '/' id_num TO id_num",
"command : id_num TO id_num",
"command : ID OF ID IS '[' NUM ',' NUM ',' NUM ')'",
"command : ID OF ID IS '(' NUM ',' NUM ',' NUM ']'",
"command : ID OF ID IS '(' NUM ',' NUM ',' NUM ',' NUM ')'",
"command : INTERVAL OF ID IS '{' num_list '}'",
"command : DERIVE INTERVAL FOR var_list USING ID",
"command : LEARN INTERVAL FOR ID USING ID",
"command : LIST DESCRIPTIONS",
"command : PLOT DESCRIPTIONS",
"command : SET RULE encode_rules_type",
"command : FAM ID FOR ID IS '{' str_list '}'",
"command : LIST ALL FAM",
"command : LIST FAM ID FOR ID",
"command : LIST FAM",
"command : LIST",
"command : VECT",
"command : LIST RULE",
"command : SORT RULE",
"command : PLOT FAM",
"command : SEL FAM ID FOR ID",
"command : SHOW CURRENT FAM",
"command : FAM ID FOR ID RULE NUM '=' ID",
"command : RULE NUM '=' ID",
"command : RULE NUM '=' NUM",
"command : RULE '(' str_list ')'",
"command : RULE TABLE prepare_rt '{' poss_nl rule_table poss_nl '}'",
"command : SET APRIORY ID",
"command : RULE RULE TABLE prepare_rt '{' poss_nl i_rule_table poss_nl '}'",
"command : DEL RULE INUM",
"command : DEL RULE '(' str_list ')'",
"command : DEL RULE",
"command : IMP NUM '=' NUM",
"command : RESET RULE USAGE FOR ID",
"command : RESET NUM",
"command : RESET ID",
"command : TEST DUPLICATE ID",
"command : MERGE DUPLICATE ID",
"command : EXPAND RULE",
"command : EXPAND RULE num",
"command : LIST TABLE",
"command : COPY ID TO TABLE ID",
"command : SAVE RULE IN TABLE ID",
"command : DEL TABLE ID",
"command : LIST TABLE ID",
"command : COPY num '%' OF TABLE ID TO ID",
"command : SPLIT num '%' OF ID TO ID AND ID",
"command : COPY RULE FROM ID TO ID",
"command : COMPARE ID TO TABLE ID",
"command : COUNT RULE ID",
"command : LIST APRIORY",
"command : TREE ID",
"command : TREE ID INFORMATIVITY",
"command : TREE ID GINI",
"command : TREE ID GR",
"command : TREE ID RELIEFF",
"command : LIST TREE ID",
"command : SET REPEAT TEST NUM",
"command : SET SAVE TEST yesno",
"command : TEST DECOMPOSE ID FOR NUM TO NUM STEP NUM RULE OF ID",
"command : SET DECOMPOSE LOCAL",
"command : SET DECOMPOSE GLOBAL",
"command : SET DECOMPOSE CM",
"command : SET DECOMPOSE DFC",
"command : SET DECOMPOSE ERROR",
"command : SET DECOMPOSE MNUMBER",
"command : SET DECOMPOSE SDTIC",
"command : SET DECOMPOSE DTIC",
"command : SET DECOMPOSE INUM",
"command : SET DECOMPOSE INUM TO INUM",
"command : SET DECOMPOSE INUM AND INUM",
"command : SET DECOMPOSE INUM TO INUM AND INUM TO INUM",
"command : TEST REDUNDANT ID",
"command : DEL REDUNDANT ID",
"command : DEL REDUNDANT INFORMATIVITY ID",
"command : DEL REDUNDANT GINI ID",
"command : DEL REDUNDANT GR ID",
"command : DEL REDUNDANT RELIEFF ID",
"command : TEST REDUNDANT ID FOR var_list",
"command : DEL REDUNDANT ID FOR var_list",
"command : YLOG INFORMATIVITY",
"command : YLOG RELIEFF",
"command : YLOG GINI",
"command : YLOG GR",
"command : YLOG MDL",
"command : SET DEBUG INFORMATIVITY yesno",
"command : SET DEBUG RELIEFF yesno",
"command : SET DEBUG GINI yesno",
"command : SET DEBUG GR yesno",
"command : SET DM yesno",
"command : DFC ID",
"command : SDTIC ID",
"command : DTIC ID",
"command : DECOMPOSE INFORMATIVITY ID INUM",
"command : DECOMPOSE GINI ID INUM",
"command : DECOMPOSE GR ID INUM",
"command : DECOMPOSE RELIEFF ID INUM",
"command : DECOMPOSE MDL ID INUM",
"command : SET DECOMPOSE DECOMPOSE INUM",
"command : LIST OPT",
"command : LIST OPT ALL",
"command : DEL OPT ID",
"command : SET OPT ID",
"command : SEL OPT ID",
"command : ID '=' NUM",
"command : ID '=' '{' q_list '}'",
"command : ID '=' ID",
"command : EXPECT ID '=' NUM",
"command : EVALUATE ID",
"command : EVALUATE ID FOR ID",
"command : DERIVE var_list",
"command : DERIVE var_list FOR ID",
"command : DERIVE var_list FOR ALL",
"command : DERIVE var_list FOR '{' str_list '}'",
"command : LIST ID FOR ALL",
"command : PLOT ID",
"command : LIST ID FOR '{' str_list '}'",
"command : UNDEF OPT",
"command : EVALUATE INUM",
"command : SET EVALUATE eval_type",
"command : INSTANCE TABLE ID FOR ID '{' poss_nl str_list '}'",
"command : LIST INSTANCE TABLE",
"command : LIST INSTANCE TABLE ID",
"command : DERIVE INSTANCE TABLE ID",
"command : SEL INSTANCE NUM FROM ID",
"command : LOAD INSTANCE FROM ID",
"command : DERIVE RULE TABLE ID FROM INSTANCE TABLE ID",
"command : DERIVE RULE FOR ID FROM INSTANCE TABLE ID",
"command : ID FROM INSTANCE TABLE ID",
"command : SPLIT num '%' INSTANCE TABLE ID TO ID AND ID",
"command : SET GA POPULATION INUM",
"command : SET GA ITERATIONS INUM",
"command : SET GA DESCRIPTIONS POINTS '=' NUM",
"command : SET GA WEIGHT POINTS '=' NUM",
"command : SET GA PRINT FREQ '=' NUM",
"command : SET GA WIDTH '=' NUM",
"command : SET MAX PLOT ERROR '=' NUM",
"command : SET ERROR ga_error_entry",
"command : SET AND '=' fand",
"command : SET GA MUTATION FAM '=' NUM",
"command : SET GA MUTATION DESCRIPTIONS '=' NUM",
"command : SET GA MUTATION WEIGHT '=' NUM",
"command : SET GA CROSSOVER FAM '=' NUM",
"command : SET GA CROSSOVER DESCRIPTIONS '=' NUM",
"command : SET GA CROSSOVER WEIGHT '=' NUM",
"command : SET GA LEARN FAM '=' yesno",
"command : SET GA LEARN DESCRIPTIONS '=' yesno",
"command : SET GA LEARN WEIGHT '=' yesno",
"command : SET GA POLICY '=' ga_policy_entry",
"command : LEARN FAM FOR ID",
"command : LEARN WEIGHT FOR ID",
"command : LEARN DESCRIPTIONS FOR ID",
"command : LEARN FOR ID",
"command : LEARN var_list",
"command : LEARN FAM ID FOR ID",
"command : STAT FOR ID",
"command : STAT FOR INSTANCE TABLE ID",
"command : PLOT GA ERROR",
"command : TEST DECOMPOSE ID",
"command : DECOMPOSE ID",
"command : COMPOSE ID",
"command : ONE DECOMPOSE ID",
"command : DECOMPOSE TABLE ID ON var_list AND var_list",
"command : JOIN var_list OF ID TO ID",
"command : JOIN var_list AND var_list OF ID TO ID",
"command : PJOIN var_list OF ID TO ID",
"command : PJOIN var_list AND var_list OF ID TO ID",
"command : FJOIN",
"command : SET HEURISTIC SPLIT yesno",
"command : SET HEURISTIC COMPUTE yesno",
"command : SET DECOMPOSE DEBUG INUM",
"command : SET DECOMPOSE KNN NUM",
"command : SET COLOR coloring_entry",
"command : SET SAVE COLOR yesno",
"command : SET SAVE COLOR ID",
"command : ANALYZE COLOR",
"command : LIST COLOR",
"command : LIST GROUP",
"command : LIST INSTANCE",
"command : LIST DM",
"command : INSTANCE NUM TO NUM",
"command : SET COLOR STRING",
"command : SURE COLOR",
"command : NEED COLOR",
"command : SAME NUM NUM",
"command : DIFFERENT NUM NUM",
"command : SET COLOR ON",
"command : num '%' NOISE TO ID",
"command : SET MNUMBER num",
"command : TEST ERROR",
"command : TEST num",
"command : TEST num num",
"command : TEST EVALUATE",
"command : MERGE INUM INUM",
"command : MERGE",
"command : MERGE INUM",
"command : TEST MERGE num num STEP num",
"command : MERGE EVALUATE",
"command : PAIRS",
"command : SET NOISE MNUMBER",
"command : SET NOISE MNUMBER CM",
"command : SET NOISE MNUMBER ERROR",
"command : SET NOISE MNUMBER CM ERROR",
"command : SET NOISE INFORMATIVITY",
"command : SET NOISE LAPLACE",
"command : SET NOISE CLUSTER",
"command : SET DONTCARE",
"command : SET DONTKNOW",
"command : SET APRIORY",
"command : SEED num",
"command : SET DISTRIBUTION",
"command : SET CV",
"command : SET CV INUM",
"command : SET SAMPLE",
"command : SET SAMPLE num num INUM",
"command : SET CV INUM FOR ID",
"command : SPLIT ID TO ID AND ID USING INUM",
"command : SET NOISE LOCAL",
"command : SET NOISE GLOBAL",
"command : LOAD ID",
"command : LOAD RULE ID",
"command : LOAD RULE ID USING INUM",
"command : SAVE STRUCTURE ID",
"command : SAVE DESCRIPTIONS ID",
"command : SAVE RULE ID",
"command : SAVE OPT ID",
"command : SAVE ID",
"command : WRITE ID TO ID",
"command : WRITE ID ID TO ID",
"command : WRITE RULE ID TO ID",
"command : WRITE NAMES ID TO ID",
"command : WRITE DOT ID TO ID",
"command : SEL ID",
"command : SHOW",
"command : DEBUG EVALUATE",
"command : DEBUG GA",
"command : DEBUG DESCRIPTIONS",
"command : PREFER QUALITATIVE",
"command : PREFER QUANTITATIVE",
"command : VAR PREFIX ID",
"command : OPT PREFIX ID",
"command : WAIT NUM",
"command : YECHO STRING",
"command : YLOG STRING",
"command : COLOR",
"command : QUIT",
"yesno : YES",
"yesno : NO",
"fand : MIN",
"fand : MAX",
"fand : MULT",
"eval_type : FUZZY",
"eval_type : CRISP",
"eval_type : INTERVAL",
"coloring_entry : OPT",
"coloring_entry : HEURISTIC",
"coloring_entry : GA",
"coloring_entry : SET",
"ga_error_entry : GAABS",
"ga_error_entry : LSQR",
"ga_error_entry : '%'",
"ga_error_entry : LSQR '%'",
"ga_error_entry : MAX '%'",
"ga_error_entry : NORM",
"ga_policy_entry : AND",
"ga_policy_entry : OR",
"ga_policy_entry : CUSTOM",
"new_vars : new_vars ',' new_var",
"new_vars : new_var",
"new_var : ID",
"str_list : str_list_rev",
"str_list_rev : str_list_rev separator_nl ID",
"str_list_rev : str_list_rev separator_nl NUM",
"str_list_rev : str_list_rev separator_nl INUM",
"str_list_rev : str_list_rev separator_nl '?'",
"str_list_rev : ID",
"str_list_rev : '?'",
"str_list_rev : NUM",
"str_list_rev : INUM",
"num_list : num_list_rev",
"num_list_rev : num_list_rev separator_nl num",
"num_list_rev : num",
"separator_nl : ','",
"separator_nl : ';'",
"separator_nl : '\\n'",
"separator_nl :",
"separator : ','",
"separator : ';'",
"separator :",
"poss_nl : '\\n'",
"poss_nl :",
"var_list : var_list_rev",
"var_list_rev : var_list_rev ',' ID",
"var_list_rev : ID",
"q_list : q_list ',' q_list_el",
"q_list : q_list_el",
"q_list_el : ID '/' NUM",
"q_list_el : NUM '/' NUM",
"rule_table : rule_table '\\n' att_entry",
"rule_table : att_entry",
"att_entry : att_entry separator att_id",
"att_entry : att_id",
"att_id : id_num",
"i_rule_table : i_rule_table '\\n' i_att_entry",
"i_rule_table : i_att_entry",
"i_att_entry : i_att_entry separator i_att_id",
"i_att_entry : i_att_id",
"i_att_id : INUM",
"id_num : ID",
"id_num : NUM",
"id_num : INUM",
"id_num : '?'",
"num : NUM",
"num : INUM",
"prepare_rt :",
"encode_rules_type : TABLE",
"encode_rules_type : LIST",
"encode_rules_type : TREE",

};
#endif

int      yydebug;
int      yynerrs;

int      yyerrflag;
int      yychar;
YYSTYPE  yyval;
YYSTYPE  yylval;

/* define the initial stack-sizes */
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH  YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH  10000
#endif
#endif

#define YYINITSTACKSIZE 200

typedef struct {
    unsigned stacksize;
    YYINT    *s_base;
    YYINT    *s_mark;
    YYINT    *s_last;
    YYSTYPE  *l_base;
    YYSTYPE  *l_mark;
} YYSTACKDATA;
/* variables for the parser stack */
static YYSTACKDATA yystack;
#line 1224 "cmd.y"

yyerror()
{
  if (!interact_mode) {
    printf("Syntax error detected in line %d\n",yylineno);
    ++n_errors;
  }
}
#line 1173 "y.tab.c"

#if YYDEBUG
#include <stdio.h>		/* needed for printf */
#endif

#include <stdlib.h>	/* needed for malloc, etc */
#include <string.h>	/* needed for memset */

/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack(YYSTACKDATA *data)
{
    int i;
    unsigned newsize;
    YYINT *newss;
    YYSTYPE *newvs;

    if ((newsize = data->stacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return YYENOMEM;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;

    i = (int) (data->s_mark - data->s_base);
    newss = (YYINT *)realloc(data->s_base, newsize * sizeof(*newss));
    if (newss == 0)
        return YYENOMEM;

    data->s_base = newss;
    data->s_mark = newss + i;

    newvs = (YYSTYPE *)realloc(data->l_base, newsize * sizeof(*newvs));
    if (newvs == 0)
        return YYENOMEM;

    data->l_base = newvs;
    data->l_mark = newvs + i;

    data->stacksize = newsize;
    data->s_last = data->s_base + newsize - 1;
    return 0;
}

#if YYPURE || defined(YY_NO_LEAKS)
static void yyfreestack(YYSTACKDATA *data)
{
    free(data->s_base);
    free(data->l_base);
    memset(data, 0, sizeof(*data));
}
#else
#define yyfreestack(data) /* nothing */
#endif

#define YYABORT  goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR  goto yyerrlab

int
YYPARSE_DECL()
{
    int yym, yyn, yystate;
#if YYDEBUG
    const char *yys;

    if ((yys = getenv("YYDEBUG")) != 0)
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = YYEMPTY;
    yystate = 0;

#if YYPURE
    memset(&yystack, 0, sizeof(yystack));
#endif

    if (yystack.s_base == NULL && yygrowstack(&yystack) == YYENOMEM) goto yyoverflow;
    yystack.s_mark = yystack.s_base;
    yystack.l_mark = yystack.l_base;
    yystate = 0;
    *yystack.s_mark = 0;

yyloop:
    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = YYLEX) < 0) yychar = YYEOF;
#if YYDEBUG
        if (yydebug)
        {
            yys = yyname[YYTRANSLATE(yychar)];
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
        {
            goto yyoverflow;
        }
        yystate = yytable[yyn];
        *++yystack.s_mark = yytable[yyn];
        *++yystack.l_mark = yylval;
        yychar = YYEMPTY;
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;

    YYERROR_CALL("syntax error");

    goto yyerrlab;

yyerrlab:
    ++yynerrs;

yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yystack.s_mark]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yystack.s_mark, yytable[yyn]);
#endif
                if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
                {
                    goto yyoverflow;
                }
                yystate = yytable[yyn];
                *++yystack.s_mark = yytable[yyn];
                *++yystack.l_mark = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yystack.s_mark);
#endif
                if (yystack.s_mark <= yystack.s_base) goto yyabort;
                --yystack.s_mark;
                --yystack.l_mark;
            }
        }
    }
    else
    {
        if (yychar == YYEOF) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = yyname[YYTRANSLATE(yychar)];
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = YYEMPTY;
        goto yyloop;
    }

yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    if (yym)
        yyval = yystack.l_mark[1-yym];
    else
        memset(&yyval, 0, sizeof yyval);
    switch (yyn)
    {
case 1:
#line 93 "cmd.y"
	{ if (interact_mode) printf(">> "); fflush(stdout); }
break;
case 2:
#line 95 "cmd.y"
	{ if (interact_mode) printf(">> "); fflush(stdout); }
break;
case 3:
#line 96 "cmd.y"
	{}
break;
case 4:
#line 97 "cmd.y"
	{}
break;
case 5:
#line 99 "cmd.y"
	{ 
  if (interact_mode) {
    printf("syntax error\n>> ");
    fflush(stdout); /* MyRefresh(); */
  }
  else {
    yyerror();
    exit(1);
  }
}
break;
case 6:
#line 115 "cmd.y"
	{}
break;
case 7:
#line 121 "cmd.y"
	{ add_var(&variables,yystack.l_mark[0].strV,TRUE,0); }
break;
case 8:
#line 122 "cmd.y"
	{ del_list_vars(&tmp_vars); }
break;
case 9:
#line 123 "cmd.y"
	{ del_list_vars(&tmp_vars); }
break;
case 10:
#line 124 "cmd.y"
	{ del_var(&variables,yystack.l_mark[0].strV); }
break;
case 11:
#line 125 "cmd.y"
	{ del_var(&variables,yystack.l_mark[0].strV); }
break;
case 12:
#line 126 "cmd.y"
	{ list_vars(variables); }
break;
case 13:
#line 127 "cmd.y"
	{ add_fam(yystack.l_mark[-5].strV, yystack.l_mark[-5].strV, yystack.l_mark[-1].strL); }
break;
case 14:
#line 128 "cmd.y"
	{ list_struct(variables, empty); }
break;
case 15:
#line 129 "cmd.y"
	{ list_informativity(yystack.l_mark[0].strV); }
break;
case 16:
#line 130 "cmd.y"
	{ print_short = yystack.l_mark[0].intV; }
break;
case 17:
#line 132 "cmd.y"
	{ var_type *v; FIND_VAR(v,yystack.l_mark[0].strV); if (v!=NULL) v->ctype=ct_nominal; }
break;
case 18:
#line 134 "cmd.y"
	{ var_type *v; FIND_VAR(v,yystack.l_mark[0].strV); if (v!=NULL) v->ctype=ct_contin; }
break;
case 19:
#line 137 "cmd.y"
	{ printf("Struct %s %s diff %6.3lf\n", yystack.l_mark[-1].strV, yystack.l_mark[0].strV, compare_struct_dist(yystack.l_mark[-1].strV, yystack.l_mark[0].strV)); }
break;
case 20:
#line 139 "cmd.y"
	{ printf("Leaves %s %d\n", yystack.l_mark[0].strV, count_id_leaves(yystack.l_mark[0].strV)); }
break;
case 21:
#line 141 "cmd.y"
	{ double d;
  int n = count_id_inodes(yystack.l_mark[0].strV,&d);
  printf("INodes %s %d(%5.2lf)\n", yystack.l_mark[0].strV, n, d); }
break;
case 22:
#line 149 "cmd.y"
	{ add_qdesc_varlist(yystack.l_mark[-4].strL, yystack.l_mark[-1].strL); }
break;
case 23:
#line 150 "cmd.y"
	{ rename_desc(yystack.l_mark[-4].strV, yystack.l_mark[-2].strV, yystack.l_mark[0].strV); }
break;
case 24:
#line 152 "cmd.y"
	{ rename_desc(cfam->out->name,yystack.l_mark[-2].strV,yystack.l_mark[0].strV); }
break;
case 25:
#line 154 "cmd.y"
	{ add_fdesc_var(yystack.l_mark[-10].strV,yystack.l_mark[-8].strV,left,yystack.l_mark[-5].doubV,yystack.l_mark[-3].doubV,yystack.l_mark[-1].doubV,0); }
break;
case 26:
#line 156 "cmd.y"
	{ add_fdesc_var(yystack.l_mark[-10].strV,yystack.l_mark[-8].strV,right,yystack.l_mark[-5].doubV,yystack.l_mark[-3].doubV,yystack.l_mark[-1].doubV,0); }
break;
case 27:
#line 158 "cmd.y"
	{ add_fdesc_var(yystack.l_mark[-12].strV,yystack.l_mark[-10].strV,regular,yystack.l_mark[-7].doubV,yystack.l_mark[-5].doubV,yystack.l_mark[-3].doubV,yystack.l_mark[-1].doubV); }
break;
case 28:
#line 159 "cmd.y"
	{ add_idesc_var(yystack.l_mark[-4].strV, yystack.l_mark[-1].numL); }
break;
case 29:
#line 161 "cmd.y"
	{ derive_int_using_itable(yystack.l_mark[0].strV, yystack.l_mark[-2].varL); }
break;
case 30:
#line 163 "cmd.y"
	{
#ifdef CBIG
  learn_intervals(yystack.l_mark[-2].strV, yystack.l_mark[0].strV); 
#endif
}
break;
case 31:
#line 168 "cmd.y"
	{ list_var_desc(variables); }
break;
case 32:
#line 169 "cmd.y"
	{ plot_var_desc(variables); }
break;
case 33:
#line 175 "cmd.y"
	{ encode_rules = yystack.l_mark[0].erV; }
break;
case 34:
#line 176 "cmd.y"
	{ add_fam(yystack.l_mark[-6].strV, yystack.l_mark[-4].strV, yystack.l_mark[-1].strL); }
break;
case 35:
#line 177 "cmd.y"
	{ list_fams(); }
break;
case 36:
#line 178 "cmd.y"
	{ list_rules(yystack.l_mark[-2].strV, yystack.l_mark[0].strV); }
break;
case 37:
#line 180 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    list_rules(cfam->name, cfam->out->name);
}
break;
case 38:
#line 187 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    list_rules(cfam->name, cfam->out->name);
}
break;
case 39:
#line 194 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    list_rules_vect(cfam);
}
break;
case 40:
#line 201 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    list_rules(cfam->name, cfam->out->name);
}
break;
case 41:
#line 208 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    sort_rules(cfam);
}
break;
case 42:
#line 215 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    plot_rules(cfam->name, cfam->out->name);
}
break;
case 43:
#line 222 "cmd.y"
	{
  cfam = find_fam(yystack.l_mark[0].strV, yystack.l_mark[-2].strV);
}
break;
case 44:
#line 226 "cmd.y"
	{
  if (cfam==NULL)
    printf("no FAM current\n");
  else
    printf("FAM %s for %s\n", cfam->name, cfam->out->name);
}
break;
case 45:
#line 233 "cmd.y"
	{
  add_rule_num(yystack.l_mark[-6].strV, yystack.l_mark[-4].strV, yystack.l_mark[-2].doubV, yystack.l_mark[0].strV);
}
break;
case 46:
#line 237 "cmd.y"
	{
  add_rule_num(cfam->name, cfam->out->name, (int) yystack.l_mark[-2].doubV, yystack.l_mark[0].strV);
}
break;
case 47:
#line 241 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else {
    Str255 s;
    sprintf(s, "%d", (int)yystack.l_mark[0].doubV);
    add_rule_num(cfam->name, cfam->out->name, (int) yystack.l_mark[-2].doubV, s);
  }
}
break;
case 48:
#line 251 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    add_rule_str(cfam->name, cfam->out->name, yystack.l_mark[-1].strL);
}
break;
case 49:
#line 258 "cmd.y"
	{
  set_apriory(cfam);
}
break;
case 50:
#line 262 "cmd.y"
	{
  set_apriory_id(yystack.l_mark[0].strV);
}
break;
case 51:
#line 266 "cmd.y"
	{
  set_apriory(cfam);
}
break;
case 52:
#line 270 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else {
    int n = (int) yystack.l_mark[0].intV;
    if (cfam->er == er_table) {
      if (n<0 || n>=cfam->n_rules)
	printf("error: illegal rule number %d\n", n);
      else 
	cfam->rtp[n] = undef;
    }
    else if (cfam->er == er_list) {
      rule_list *rl, *lrl;
      int i;
      if (n==0) cfam->lrule = cfam->lrule->next;
      else {
	rl = lrl = cfam->lrule;
	for (i=0; i<n; i++, rl=rl->next)
	  lrl =rl;
	lrl->next = rl->next;
      }
    }
  }
}
break;
case 53:
#line 295 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    del_rule_str(cfam->name, cfam->out->name, yystack.l_mark[-1].strL);
}
break;
case 54:
#line 302 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    del_rules(cfam);
}
break;
case 55:
#line 309 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    if (yystack.l_mark[-2].doubV<cfam->n_rules && yystack.l_mark[-2].doubV>=0 && yystack.l_mark[0].doubV>=0 && yystack.l_mark[0].doubV<=1)
      cfam->imp[(int)yystack.l_mark[-2].doubV] = yystack.l_mark[0].doubV;
    else
      printf("error: parameters out of range\n");
}
break;
case 56:
#line 318 "cmd.y"
	{ reset_rule_usage(yystack.l_mark[0].strV);}
break;
case 57:
#line 319 "cmd.y"
	{ printf("Number %lf\n", yystack.l_mark[0].doubV); }
break;
case 58:
#line 320 "cmd.y"
	{ printf("Id %s\n", yystack.l_mark[0].strV); }
break;
case 59:
#line 321 "cmd.y"
	{ test_duplicates(yystack.l_mark[0].strV); }
break;
case 60:
#line 322 "cmd.y"
	{ merge_duplicates(yystack.l_mark[0].strV); }
break;
case 61:
#line 323 "cmd.y"
	{ expand_rules(cfam); }
break;
case 62:
#line 324 "cmd.y"
	{ extern double min_exp_w;
					  min_exp_w=yystack.l_mark[0].doubV;
					  expand_rules(cfam); }
break;
case 63:
#line 332 "cmd.y"
	{ list_tables(); }
break;
case 64:
#line 334 "cmd.y"
	{ copy_to_table(yystack.l_mark[-3].strV, yystack.l_mark[0].strV); }
break;
case 65:
#line 336 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else
    copy_to_table(cfam->out->name, yystack.l_mark[0].strV);
}
break;
case 66:
#line 342 "cmd.y"
	{ del_table(yystack.l_mark[0].strV); }
break;
case 67:
#line 343 "cmd.y"
	{ list_table(yystack.l_mark[0].strV); }
break;
case 68:
#line 345 "cmd.y"
	{ copy_table(yystack.l_mark[-2].strV, yystack.l_mark[0].strV, yystack.l_mark[-6].doubV); }
break;
case 69:
#line 347 "cmd.y"
	{ split_rules(yystack.l_mark[-4].strV, yystack.l_mark[-2].strV, yystack.l_mark[0].strV, yystack.l_mark[-7].doubV); }
break;
case 70:
#line 348 "cmd.y"
	{ copy_table(yystack.l_mark[-2].strV, yystack.l_mark[0].strV, 100); }
break;
case 71:
#line 349 "cmd.y"
	{ compare_table_var(yystack.l_mark[0].strV, yystack.l_mark[-3].strV); }
break;
case 72:
#line 350 "cmd.y"
	{ count_id_rules(yystack.l_mark[0].strV); }
break;
case 73:
#line 351 "cmd.y"
	{ list_apriory(cfam); }
break;
case 74:
#line 356 "cmd.y"
	{ derive_dec_tree(yystack.l_mark[0].strV,0); }
break;
case 75:
#line 357 "cmd.y"
	{ derive_dec_tree(yystack.l_mark[-1].strV,0); }
break;
case 76:
#line 358 "cmd.y"
	{ derive_dec_tree(yystack.l_mark[-1].strV,1); }
break;
case 77:
#line 359 "cmd.y"
	{ derive_dec_tree(yystack.l_mark[-1].strV,2); }
break;
case 78:
#line 360 "cmd.y"
	{ derive_dec_tree(yystack.l_mark[-1].strV,3); }
break;
case 79:
#line 362 "cmd.y"
	{ list_dec_tree(yystack.l_mark[0].strV); }
break;
case 80:
#line 368 "cmd.y"
	{ repeat_tests = (int) yystack.l_mark[0].doubV; }
break;
case 81:
#line 369 "cmd.y"
	{ save_tests = yystack.l_mark[0].chV; }
break;
case 82:
#line 371 "cmd.y"
	{
  test_decomposition(yystack.l_mark[-9].strV, yystack.l_mark[0].strV, (int)yystack.l_mark[-7].doubV, (int)yystack.l_mark[-5].doubV, (int)yystack.l_mark[-3].doubV);
}
break;
case 83:
#line 374 "cmd.y"
	{ dec_global = FALSE; }
break;
case 84:
#line 375 "cmd.y"
	{ dec_global = TRUE; }
break;
case 85:
#line 377 "cmd.y"
	{ dec_crit = c_cm; }
break;
case 86:
#line 378 "cmd.y"
	{ dec_crit = c_dfc; }
break;
case 87:
#line 379 "cmd.y"
	{ dec_crit = c_error; }
break;
case 88:
#line 380 "cmd.y"
	{ dec_crit = c_m; }
break;
case 89:
#line 381 "cmd.y"
	{ dec_crit = c_r; }
break;
case 90:
#line 382 "cmd.y"
	{ dec_crit = c_cr; }
break;
case 91:
#line 385 "cmd.y"
	{ n_dis_lo = n_dis_hi = yystack.l_mark[0].intV; }
break;
case 92:
#line 386 "cmd.y"
	{ n_dis_lo = yystack.l_mark[-2].intV; n_dis_hi = yystack.l_mark[0].intV; }
break;
case 93:
#line 388 "cmd.y"
	{ n_dis_lo = n_dis_hi = yystack.l_mark[-2].intV; n_ndis_lo = n_ndis_hi = yystack.l_mark[0].intV; }
break;
case 94:
#line 390 "cmd.y"
	{ n_dis_lo = yystack.l_mark[-6].intV; n_dis_hi = yystack.l_mark[-4].intV; n_ndis_lo = yystack.l_mark[-2].intV; n_ndis_hi = yystack.l_mark[0].intV; }
break;
case 95:
#line 391 "cmd.y"
	{ check_redundant(yystack.l_mark[0].strV, FALSE, NULL); }
break;
case 96:
#line 392 "cmd.y"
	{ check_redundant(yystack.l_mark[0].strV, TRUE, NULL); }
break;
case 97:
#line 394 "cmd.y"
	{ del_redundant_sorted(yystack.l_mark[0].strV, M_INFORM, NULL); }
break;
case 98:
#line 396 "cmd.y"
	{ del_redundant_sorted(yystack.l_mark[0].strV, M_GINI, NULL); }
break;
case 99:
#line 398 "cmd.y"
	{ del_redundant_sorted(yystack.l_mark[0].strV, M_GR, NULL); }
break;
case 100:
#line 400 "cmd.y"
	{ del_redundant_sorted(yystack.l_mark[0].strV, M_RELIEFF, NULL); }
break;
case 101:
#line 402 "cmd.y"
	{ check_redundant(yystack.l_mark[-2].strV, FALSE, yystack.l_mark[0].varL); }
break;
case 102:
#line 404 "cmd.y"
	{ check_redundant(yystack.l_mark[-2].strV, TRUE, yystack.l_mark[0].varL); }
break;
case 103:
#line 405 "cmd.y"
	{ log_inform = !log_inform; }
break;
case 104:
#line 406 "cmd.y"
	{ log_relieff = !log_relieff; }
break;
case 105:
#line 407 "cmd.y"
	{ log_gini = !log_gini; }
break;
case 106:
#line 408 "cmd.y"
	{ log_gr = !log_gr; }
break;
case 107:
#line 409 "cmd.y"
	{ log_mdl = !log_mdl; }
break;
case 108:
#line 410 "cmd.y"
	{ deb_inform = yystack.l_mark[0].chV; }
break;
case 109:
#line 411 "cmd.y"
	{ deb_relieff = yystack.l_mark[0].chV; }
break;
case 110:
#line 412 "cmd.y"
	{ deb_gini = yystack.l_mark[0].chV; }
break;
case 111:
#line 413 "cmd.y"
	{ deb_gr = yystack.l_mark[0].chV; }
break;
case 112:
#line 414 "cmd.y"
	{ use_dm = yystack.l_mark[0].chV; }
break;
case 113:
#line 416 "cmd.y"
	{ printf("dfc %s is %d\n", yystack.l_mark[0].strV, get_dfc_measure(yystack.l_mark[0].strV)); }
break;
case 114:
#line 418 "cmd.y"
	{ printf("sdtic %s is %5.3lf\n", yystack.l_mark[0].strV, get_code_measure(yystack.l_mark[0].strV)); }
break;
case 115:
#line 420 "cmd.y"
	{
  extern double get_dtic_measure(Str255 vname);
  printf("dtic %s is %5.3lf\n", yystack.l_mark[0].strV, get_dtic_measure(yystack.l_mark[0].strV));
}
break;
case 116:
#line 425 "cmd.y"
	{ fast_decompose(yystack.l_mark[-1].strV, M_INFORM, (int)yystack.l_mark[0].intV); }
break;
case 117:
#line 426 "cmd.y"
	{ fast_decompose(yystack.l_mark[-1].strV, M_GINI, yystack.l_mark[0].intV); }
break;
case 118:
#line 427 "cmd.y"
	{ fast_decompose(yystack.l_mark[-1].strV, M_GR, yystack.l_mark[0].intV); }
break;
case 119:
#line 428 "cmd.y"
	{ fast_decompose(yystack.l_mark[-1].strV, M_RELIEFF, yystack.l_mark[0].intV); }
break;
case 120:
#line 429 "cmd.y"
	{ fast_decompose(yystack.l_mark[-1].strV, M_MDL, yystack.l_mark[0].intV); }
break;
case 121:
#line 433 "cmd.y"
	{
  /* this is to use new IM derivation procedure */
  extern char dec_speed;
  dec_speed = yystack.l_mark[0].intV;
}
break;
case 122:
#line 443 "cmd.y"
	{ list_struct(variables, curropt); }
break;
case 123:
#line 444 "cmd.y"
	{ list_options(); }
break;
case 124:
#line 445 "cmd.y"
	{ del_opt(yystack.l_mark[0].strV); }
break;
case 125:
#line 446 "cmd.y"
	{ set_opt(yystack.l_mark[0].strV); }
break;
case 126:
#line 447 "cmd.y"
	{ select_opt(yystack.l_mark[0].strV); }
break;
case 127:
#line 450 "cmd.y"
	{
  Str255 s;
  if (pref_qual) {
    sprintf(s, "%d", (int)yystack.l_mark[0].doubV);
    set_var_val_q(yystack.l_mark[-2].strV,s);
  }
  else set_var_val_num(yystack.l_mark[-2].strV, yystack.l_mark[0].doubV);
}
break;
case 128:
#line 458 "cmd.y"
	{ set_var_val_qlist(yystack.l_mark[-4].strV, yystack.l_mark[-1].strQ); }
break;
case 129:
#line 459 "cmd.y"
	{ set_var_val_q(yystack.l_mark[-2].strV,yystack.l_mark[0].strV); }
break;
case 130:
#line 460 "cmd.y"
	{ set_var_expect(yystack.l_mark[-2].strV, yystack.l_mark[0].doubV); }
break;
case 131:
#line 461 "cmd.y"
	{ evaluate(yystack.l_mark[0].strV); }
break;
case 132:
#line 463 "cmd.y"
	{
  if (find_opt(yystack.l_mark[0].strV, TRUE) != NULL) {
    select_opt(yystack.l_mark[0].strV);
    evaluate(yystack.l_mark[-2].strV);
    set_opt(yystack.l_mark[0].strV);
  }
}
break;
case 133:
#line 470 "cmd.y"
	{ derive_lvar(yystack.l_mark[0].varL); }
break;
case 134:
#line 472 "cmd.y"
	{
  if (find_opt(yystack.l_mark[0].strV, TRUE) != NULL) {
    select_opt(yystack.l_mark[0].strV);
    derive_lvar(yystack.l_mark[-2].varL);
    set_opt(yystack.l_mark[0].strV);
  }
}
break;
case 135:
#line 480 "cmd.y"
	{
  list_of_opt *opt;
  for (opt=options; opt!=NULL; opt=opt->next) {
    select_opt(opt->name);
    derive_lvar(yystack.l_mark[-2].varL);
    set_opt(opt->name);
  }
}
break;
case 136:
#line 489 "cmd.y"
	{
  list_of_str *s;
  for (s=yystack.l_mark[-1].strL; s!=NULL; s=s->next)
    if (find_opt(s->str, TRUE) != NULL) {
      select_opt(s->str);
      derive_lvar(yystack.l_mark[-4].varL);
      set_opt(s->str);
    }
}
break;
case 137:
#line 498 "cmd.y"
	{ list_var_opt_all(yystack.l_mark[-2].strV); }
break;
case 138:
#line 499 "cmd.y"
	{ plot_var_opt_all(yystack.l_mark[0].strV); }
break;
case 139:
#line 500 "cmd.y"
	{ list_var_opt_str(yystack.l_mark[-4].strV, yystack.l_mark[-1].strL); }
break;
case 140:
#line 502 "cmd.y"
	{
				/* BBB try not only to undefine the
                                   whole option, but also just
                                   internal nodes */
  undefine_opt();
}
break;
case 141:
#line 508 "cmd.y"
	{extern char evaltype; evaltype=yystack.l_mark[0].intV;}
break;
case 142:
#line 509 "cmd.y"
	{ eval_method = yystack.l_mark[0].evalV; }
break;
case 143:
#line 511 "cmd.y"
	{ add_itable(yystack.l_mark[-6].strV, yystack.l_mark[-4].strV, yystack.l_mark[-1].strL); }
break;
case 144:
#line 512 "cmd.y"
	{ list_instance_tables(); }
break;
case 145:
#line 513 "cmd.y"
	{ list_instance_table(yystack.l_mark[0].strV,FALSE); }
break;
case 146:
#line 514 "cmd.y"
	{ list_instance_table(yystack.l_mark[0].strV,TRUE); }
break;
case 147:
#line 516 "cmd.y"
	{ load_instance_from_table((int)yystack.l_mark[-2].doubV,yystack.l_mark[0].strV);}
break;
case 148:
#line 517 "cmd.y"
	{ load_instances_from_table(yystack.l_mark[0].strV); }
break;
case 149:
#line 520 "cmd.y"
	{ derive_rtable_from_itable(yystack.l_mark[-4].strV, yystack.l_mark[0].strV, TRUE); }
break;
case 150:
#line 522 "cmd.y"
	{ derive_rtable_from_itable(yystack.l_mark[-4].strV, yystack.l_mark[0].strV, FALSE); }
break;
case 151:
#line 525 "cmd.y"
	{ discretize(yystack.l_mark[-4].strV, yystack.l_mark[0].strV); }
break;
case 152:
#line 528 "cmd.y"
	{ split_instance_table(yystack.l_mark[-4].strV, yystack.l_mark[-2].strV, yystack.l_mark[0].strV, yystack.l_mark[-8].doubV); }
break;
case 153:
#line 534 "cmd.y"
	{ ga_population_size = yystack.l_mark[0].intV; }
break;
case 154:
#line 535 "cmd.y"
	{ ga_maxiter = yystack.l_mark[0].intV; }
break;
case 155:
#line 536 "cmd.y"
	{ ga_desc_pts = yystack.l_mark[0].doubV; }
break;
case 156:
#line 537 "cmd.y"
	{ ga_weight_pts = yystack.l_mark[0].doubV; }
break;
case 157:
#line 538 "cmd.y"
	{ ga_print_freq = yystack.l_mark[0].doubV; }
break;
case 158:
#line 539 "cmd.y"
	{ ga_width = yystack.l_mark[0].doubV; }
break;
case 159:
#line 540 "cmd.y"
	{ ga_max_error = yystack.l_mark[0].doubV; }
break;
case 160:
#line 541 "cmd.y"
	{ ga_error_method = yystack.l_mark[0].gaeV; }
break;
case 161:
#line 542 "cmd.y"
	{ fa_method = yystack.l_mark[0].faV; }
break;
case 162:
#line 543 "cmd.y"
	{ ga_mut_fams = yystack.l_mark[0].doubV; }
break;
case 163:
#line 544 "cmd.y"
	{ ga_mut_desc = yystack.l_mark[0].doubV; }
break;
case 164:
#line 545 "cmd.y"
	{ ga_mut_w = yystack.l_mark[0].doubV; }
break;
case 165:
#line 546 "cmd.y"
	{ ga_cross_fams = yystack.l_mark[0].doubV; }
break;
case 166:
#line 547 "cmd.y"
	{ ga_cross_desc = yystack.l_mark[0].doubV; }
break;
case 167:
#line 548 "cmd.y"
	{ ga_cross_w = yystack.l_mark[0].doubV; }
break;
case 168:
#line 549 "cmd.y"
	{ ga_learn_fams = yystack.l_mark[0].chV; }
break;
case 169:
#line 550 "cmd.y"
	{ ga_learn_desc = yystack.l_mark[0].chV; }
break;
case 170:
#line 551 "cmd.y"
	{ ga_learn_w = yystack.l_mark[0].chV; }
break;
case 171:
#line 552 "cmd.y"
	{ ga_policy = yystack.l_mark[0].gapV; }
break;
case 172:
#line 553 "cmd.y"
	{}
break;
case 173:
#line 554 "cmd.y"
	{}
break;
case 174:
#line 555 "cmd.y"
	{}
break;
case 175:
#line 556 "cmd.y"
	{}
break;
case 176:
#line 558 "cmd.y"
	{
#ifdef CBIG
  ga_learn(yystack.l_mark[0].varL);
#endif
}
break;
case 177:
#line 563 "cmd.y"
	{}
break;
case 178:
#line 564 "cmd.y"
	{ stat_for_var(yystack.l_mark[0].strV); }
break;
case 179:
#line 566 "cmd.y"
	{
  printf("Error: %10.5lf\n", stat_for_itable(yystack.l_mark[0].strV));
}
break;
case 180:
#line 570 "cmd.y"
	{
#ifdef CBIG
  plot_ga_error();
#endif
}
break;
case 181:
#line 580 "cmd.y"
	{ bottom_up_decompose(yystack.l_mark[0].strV,TRUE,TRUE);}
break;
case 182:
#line 582 "cmd.y"
	{ 
  if (dec_global) global_decompose(yystack.l_mark[0].strV,TRUE,FALSE);
  else bottom_up_decompose(yystack.l_mark[0].strV,TRUE,FALSE);
}
break;
case 183:
#line 587 "cmd.y"
	{ compose(yystack.l_mark[0].strV); }
break;
case 184:
#line 588 "cmd.y"
	{ bottom_up_decompose(yystack.l_mark[0].strV,FALSE,FALSE);}
break;
case 185:
#line 590 "cmd.y"
	{ decomposition_table(yystack.l_mark[-4].strV, yystack.l_mark[-2].varL, yystack.l_mark[0].varL); }
break;
case 186:
#line 593 "cmd.y"
	{ join_nodes(yystack.l_mark[-4].varL,NULL,yystack.l_mark[-2].strV,yystack.l_mark[0].strV,0); }
break;
case 187:
#line 595 "cmd.y"
	{ join_nodes(yystack.l_mark[-6].varL,yystack.l_mark[-4].varL,yystack.l_mark[-2].strV,yystack.l_mark[0].strV,0); }
break;
case 188:
#line 597 "cmd.y"
	{ join_nodes(yystack.l_mark[-4].varL,NULL,yystack.l_mark[-2].strV,yystack.l_mark[0].strV,1); }
break;
case 189:
#line 599 "cmd.y"
	{ join_nodes(yystack.l_mark[-6].varL,yystack.l_mark[-4].varL,yystack.l_mark[-2].strV,yystack.l_mark[0].strV,1); }
break;
case 190:
#line 601 "cmd.y"
	{ join_nodes(NULL,NULL,NULL,NULL,2); }
break;
case 191:
#line 603 "cmd.y"
	{ heur_split = yystack.l_mark[0].chV; }
break;
case 192:
#line 604 "cmd.y"
	{ heur_comp = yystack.l_mark[0].chV; }
break;
case 193:
#line 605 "cmd.y"
	{ deb_dec = yystack.l_mark[0].intV; }
break;
case 194:
#line 606 "cmd.y"
	{ krelieff = yystack.l_mark[0].doubV; }
break;
case 195:
#line 608 "cmd.y"
	{ coloring = yystack.l_mark[0].colV; }
break;
case 196:
#line 610 "cmd.y"
	{ save_im = yystack.l_mark[0].chV; }
break;
case 197:
#line 611 "cmd.y"
	{ strcpy(im_fname, yystack.l_mark[0].strV); }
break;
case 198:
#line 612 "cmd.y"
	{ analyze_current_color(); }
break;
case 199:
#line 613 "cmd.y"
	{ list_current_color(); }
break;
case 200:
#line 614 "cmd.y"
	{ list_color_groups(); }
break;
case 201:
#line 615 "cmd.y"
	{ list_unsure_instances(); }
break;
case 202:
#line 616 "cmd.y"
	{ list_ndm(); }
break;
case 203:
#line 617 "cmd.y"
	{ set_instance_to_color((int)yystack.l_mark[-2].doubV, (int)yystack.l_mark[0].doubV); }
break;
case 204:
#line 619 "cmd.y"
	{ set_color(yystack.l_mark[0].strV); }
break;
case 205:
#line 620 "cmd.y"
	{ set_sure_color(); }
break;
case 206:
#line 621 "cmd.y"
	{ set_need_color(); }
break;
case 207:
#line 622 "cmd.y"
	{ set_same_color((int)yystack.l_mark[-1].doubV,(int)yystack.l_mark[0].doubV); }
break;
case 208:
#line 623 "cmd.y"
	{ set_diff_color((int)yystack.l_mark[-1].doubV,(int)yystack.l_mark[0].doubV); }
break;
case 209:
#line 625 "cmd.y"
	{ extern char use_evidence;
					  use_evidence = TRUE;
					}
break;
case 210:
#line 633 "cmd.y"
	{ add_noise(yystack.l_mark[0].strV, yystack.l_mark[-4].doubV); }
break;
case 211:
#line 634 "cmd.y"
	{ m_param = yystack.l_mark[0].doubV; }
break;
case 212:
#line 636 "cmd.y"
	{ get_class_error();}
break;
case 213:
#line 637 "cmd.y"
	{ test(yystack.l_mark[0].doubV,0);}
break;
case 214:
#line 638 "cmd.y"
	{ test(yystack.l_mark[-1].doubV,yystack.l_mark[0].doubV);}
break;
case 215:
#line 640 "cmd.y"
	{ double e, m; 
				  int c=get_partition_error(&e,&m);
				printf("FIN c=%d e=%6.2lf %5.2lf\n", c, e,m);}
break;
case 216:
#line 643 "cmd.y"
	{ merge_colors(yystack.l_mark[-1].intV, yystack.l_mark[0].intV, -1.); }
break;
case 217:
#line 644 "cmd.y"
	{ repeat_merge(-1); }
break;
case 218:
#line 645 "cmd.y"
	{ repeat_merge(yystack.l_mark[0].intV); }
break;
case 219:
#line 646 "cmd.y"
	{ test_merge(yystack.l_mark[-3].doubV, yystack.l_mark[-2].doubV, yystack.l_mark[0].doubV); }
break;
case 220:
#line 647 "cmd.y"
	{ printf("Error: %7.3lf\n", 
					 get_class_error()); }
break;
case 221:
#line 650 "cmd.y"
	{ int i, j; double d;
				  select_pair(&i, &j, &d);
				}
break;
case 222:
#line 653 "cmd.y"
	{ noise_handling = n_mprob; }
break;
case 223:
#line 654 "cmd.y"
	{ noise_handling = n_mprob;
					  m_dec = m_cm; }
break;
case 224:
#line 656 "cmd.y"
	{ noise_handling = n_mprob;
					  m_dec = m_error; }
break;
case 225:
#line 658 "cmd.y"
	{ noise_handling = n_mprob;
					  m_dec = m_cm_error; }
break;
case 226:
#line 660 "cmd.y"
	{ noise_handling = n_entropy; }
break;
case 227:
#line 661 "cmd.y"
	{ noise_handling = n_laplace; }
break;
case 228:
#line 662 "cmd.y"
	{ noise_handling = n_cluster; }
break;
case 229:
#line 664 "cmd.y"
	{ dont_care = dc_dont_care; }
break;
case 230:
#line 665 "cmd.y"
	{ dont_care = dc_dont_know; }
break;
case 231:
#line 666 "cmd.y"
	{ dont_care = dc_apriory; }
break;
case 232:
#line 668 "cmd.y"
	{ srand((int)yystack.l_mark[0].doubV); }
break;
case 233:
#line 670 "cmd.y"
	{ use_distribution=!use_distribution; }
break;
case 234:
#line 671 "cmd.y"
	{ test_type = t_cv; }
break;
case 235:
#line 672 "cmd.y"
	{ int extern n_folds;
					  test_type = t_cv;
					  n_folds = (int)yystack.l_mark[0].intV;
					}
break;
case 236:
#line 676 "cmd.y"
	{ test_type = t_sample; }
break;
case 237:
#line 677 "cmd.y"
	{ extern int n_folds;
					  extern double p_sample_l, p_sample_mut;
					  test_type = t_sample;
					  p_sample_l = yystack.l_mark[-2].doubV; p_sample_mut = yystack.l_mark[-1].doubV;
					  n_folds = (int)yystack.l_mark[0].intV;
					}
break;
case 238:
#line 684 "cmd.y"
	{ prepare_cv(yystack.l_mark[0].strV, yystack.l_mark[-2].intV); }
break;
case 239:
#line 686 "cmd.y"
	{ split_using_cv(yystack.l_mark[-6].strV, yystack.l_mark[-4].strV, yystack.l_mark[-2].strV, yystack.l_mark[0].intV); }
break;
case 240:
#line 687 "cmd.y"
	{ char extern sel_mfreq; sel_mfreq=TRUE; }
break;
case 241:
#line 688 "cmd.y"
	{ char extern sel_mfreq; sel_mfreq=FALSE; }
break;
case 242:
#line 696 "cmd.y"
	{
  FILE *f;

  if (myno_files == MY_MAX_FILES) {
    printf("error: no of files to be loaded exceeded the limit\n");
    exit(0);
  }
  printf("load %s\n", yystack.l_mark[0].strV);
  f = fopen(yystack.l_mark[0].strV, "r");
  if (f == NULL) {
    printf("error: could not open %s as cmd file\n", yystack.l_mark[0].strV);
  }
  else {
    myno_files++;
    myfiles[myno_files].f = yyin;
    myfiles[myno_files].lineno = yylineno;
    yyin = f;
    yylineno = 1;
    interact_mode = FALSE;
  }
}
break;
case 243:
#line 722 "cmd.y"
	{ load_irules(yystack.l_mark[0].strV, cfam, 0); set_apriory(cfam); }
break;
case 244:
#line 724 "cmd.y"
	{ load_irules(yystack.l_mark[-2].strV, cfam, yystack.l_mark[0].intV); set_apriory(cfam); }
break;
case 245:
#line 729 "cmd.y"
	{ save_struct(yystack.l_mark[0].strV); }
break;
case 246:
#line 730 "cmd.y"
	{ save_des(yystack.l_mark[0].strV); }
break;
case 247:
#line 731 "cmd.y"
	{ save_rules(yystack.l_mark[0].strV); }
break;
case 248:
#line 732 "cmd.y"
	{ save_opt(yystack.l_mark[0].strV); }
break;
case 249:
#line 733 "cmd.y"
	{ save_all(yystack.l_mark[0].strV); }
break;
case 250:
#line 735 "cmd.y"
	{ save_c45_rules(yystack.l_mark[-2].strV,yystack.l_mark[0].strV);
					  save_c45_names(yystack.l_mark[-2].strV,yystack.l_mark[0].strV);
					}
break;
case 251:
#line 739 "cmd.y"
	{
  Str255 s1, s2;
  save_c45_names(yystack.l_mark[-3].strV,yystack.l_mark[0].strV);
  strcpy(s1,yystack.l_mark[0].strV);
  save_c45_rules(yystack.l_mark[-3].strV,strcat(yystack.l_mark[0].strV,".data"));
  save_c45_rules(yystack.l_mark[-2].strV,strcat(s1,".test"));
}
break;
case 252:
#line 746 "cmd.y"
	{ save_c45_rules(yystack.l_mark[-2].strV,yystack.l_mark[0].strV); }
break;
case 253:
#line 747 "cmd.y"
	{ save_c45_names(yystack.l_mark[-2].strV,yystack.l_mark[0].strV); }
break;
case 254:
#line 748 "cmd.y"
	{ save_dot_struct(yystack.l_mark[-2].strV,yystack.l_mark[0].strV); }
break;
case 255:
#line 754 "cmd.y"
	{				/* select fam or option -> FIFO  */
  var_type *v;
  list_of_opt *opt;

  if (((v = find_var(variables,yystack.l_mark[0].strV)) != NULL) &&
      find_fam(yystack.l_mark[0].strV, v->name) != NULL)
    cfam = find_fam(yystack.l_mark[0].strV, v->name);
  else if (find_opt(yystack.l_mark[0].strV,TRUE)) {
    opt = find_opt(yystack.l_mark[0].strV,TRUE);
    if (opt != NULL)
      select_opt(yystack.l_mark[0].strV);
    else
      printf("error: not found, neither a FAM nor an option\n");
  }
}
break;
case 256:
#line 770 "cmd.y"
	{
  printf("GENETIC ALGORITHM:\n");
  printf("population size    %d\n", ga_population_size);
  printf("max iterations     %d\n", ga_maxiter);
  printf("description points %d\n", ga_desc_pts);
  printf("weight points      %d\n", ga_weight_pts);
  printf("print freq         %d\n", ga_print_freq);
  printf("width (desc enlar) %lf\n", ga_width);
  printf("policy (cross,mut) %s\n",
	 ga_policy==gap_or?"or":(ga_policy==gap_and?"and":"custom"));
  printf("max plot error     %lf\n", ga_max_error);
  printf("error measure      %s\n",
	 (ga_error_method==gae_abs)?"abs":
	 (ga_error_method==gae_norm)?"norm":
	 (ga_error_method==gae_sqr)?"sqr":
	 (ga_error_method==gae_perc)?"perc":
	 (ga_error_method==gae_sqrperc)?"sqr perc":"max perc");
  printf("mutation probab    %5.2lf/L (fams) %5.2lf/L (desc) %5.2lf/L (w)\n",
	 ga_mut_fams, ga_mut_desc, ga_mut_w);
  printf("crossover probab   %5.2lf   (fams) %5.2lf   (desc) %5.2lf   (w)\n",
	 ga_cross_fams, ga_cross_desc, ga_cross_w);
  printf("learn              %s   (fams) %s   (desc) %s   (w)\n",
	 ga_learn_fams?" yes ":" no  ",
	 ga_learn_desc?" yes ":" no  ",
	 ga_learn_w?" yes ":" no  ");

  printf("\nDEBUGGING:\n");
  printf("evaluate           %s\n", debug_e ? "yes" : "no");
  printf("lexical analysis   %s\n", debug_l ? "yes" : "no");
  printf("ga learning        %s\n", debug_g ? "yes" : "no");
  printf("descriptor constr  %s\n", debug_g ? "yes" : "no");
  printf("print length       %d\n", print_short);

  printf("\nEVALUATION:\n");
  printf("fuzzy and          %s\n", (fa_method==famin)?"min" :
	 ((fa_method==famax)?"max":"mult"));

/*  printf("\nFUZZY IDENTIFICATION:\n");
  printf("init num clusters  %d\n", cl_K);
  printf("fuzziness          %5.3lf\n", cl_m);
  printf("merging treshold   %5.3lf\n", cl_gamma); 
  printf("clustering e       %7.5lf\n", cl_e);
  printf("redo the loop      %d\n", cl_redo);
  printf("sigm memberships   %s\n", cl_sigm ? "yes" : "no");
  printf("deb clust proto    %s\n", deb_cl_cp ? "yes" : "no");
  printf("data and partit    %s\n", deb_cl_pm ? "yes" : "no");
  printf("identif matrices   %s\n", deb_cl_f ? "yes" : "no"); */

  printf("\nDECOMPOSITION:\n");
  printf("coloring           %s\n", coloring==col_optimal ? "opt" :
	 coloring==col_heuristic ? "heuristic" : "ga");
  printf("m-criteria         %lf\n", mcriteria);
  printf("heuristic compute  %s\n", heur_comp ? "yes" : "no");
  printf("heuristic split    %s\n", heur_split ? "yes" : "no");
  printf("dec debug          %d\n", deb_dec);
  printf("k for NN relieff   %d\n", krelieff);
  printf("log informativity  %s\n", log_inform ? "yes" : "no");
  printf("log relieff        %s\n", log_relieff ? "yes" : "no");
  printf("log gini           %s\n", log_gini ? "yes" : "no");
  printf("log gain-ratio     %s\n", log_gr ? "yes" : "no");
  printf("debug inform       %s\n", deb_inform ? "yes" : "no");
  printf("debug relieff      %s\n", deb_relieff ? "yes" : "no");
  printf("debug gini         %s\n", deb_gini ? "yes" : "no");
  printf("debug gain-ratio   %s\n", deb_gr ? "yes" : "no");
  printf("save im            %s\n", save_im ? "yes" : "no");
  printf("save im file name  %s\n", im_fname);
  printf("bound              %d to %d\n", n_dis_lo, n_dis_hi);

  printf("\nEVALUATION / DATA REPRESENTATION:\n");
  printf("encoding rules     %s\n", encode_rules==er_table? "as table" :
	 encode_rules==er_list? "as list" : "as tree");
  printf("use dm             %s\n", use_dm?"yes":"no");
  printf("eval method        %s\n", eval_method==e_crisp? "crisp" :
	 eval_method==e_fuzzy? "fuzzy" :
	 eval_method==e_numerical? "numerical" : "interval");
  printf("entry preference   %s\n", pref_qual?"qualitative":"quantitative");
  printf("test repetition    %d\n", repeat_tests);
  printf("var prefix         %s\n", prefix_var);
  printf("opt prefix         %s\n", prefix_opt);
}
break;
case 257:
#line 850 "cmd.y"
	{ debug_e = TRUE;}
break;
case 258:
#line 852 "cmd.y"
	{ debug_g = TRUE;}
break;
case 259:
#line 853 "cmd.y"
	{ debug_d = TRUE;}
break;
case 260:
#line 854 "cmd.y"
	{ pref_qual = TRUE; }
break;
case 261:
#line 855 "cmd.y"
	{ pref_qual = FALSE; }
break;
case 262:
#line 856 "cmd.y"
	{ strcpy(prefix_var, yystack.l_mark[0].strV); iprefix_var=1; }
break;
case 263:
#line 857 "cmd.y"
	{ strcpy(prefix_opt, yystack.l_mark[0].strV); iprefix_opt=1; }
break;
case 264:
#line 859 "cmd.y"
	{
/*  struct tms bbuf, ebuf;
  times(&bbuf);
  times(&ebuf);
  while (((float)(ebuf.tms_utime-bbuf.tms_utime)/60) < $2)
    times(&ebuf); */
}
break;
case 265:
#line 866 "cmd.y"
	{ printf("%s\n", yystack.l_mark[0].strV); }
break;
case 266:
#line 867 "cmd.y"
	{ fprintf(lfile, "%s\n", yystack.l_mark[0].strV); }
break;
case 267:
#line 868 "cmd.y"
	{ color_graph(); }
break;
case 268:
#line 869 "cmd.y"
	{ exit(1); }
break;
case 269:
#line 872 "cmd.y"
	{ yyval.chV=TRUE; }
break;
case 270:
#line 873 "cmd.y"
	{ yyval.chV=FALSE; }
break;
case 271:
#line 876 "cmd.y"
	{ yyval.faV=famin; }
break;
case 272:
#line 877 "cmd.y"
	{ yyval.faV=famax; }
break;
case 273:
#line 878 "cmd.y"
	{ yyval.faV=famult; }
break;
case 274:
#line 881 "cmd.y"
	{ yyval.evalV=e_fuzzy; }
break;
case 275:
#line 882 "cmd.y"
	{ yyval.evalV=e_crisp; }
break;
case 276:
#line 883 "cmd.y"
	{ yyval.evalV=e_interval; }
break;
case 277:
#line 886 "cmd.y"
	{ yyval.colV=col_optimal; }
break;
case 278:
#line 887 "cmd.y"
	{ yyval.colV=col_heuristic; }
break;
case 279:
#line 888 "cmd.y"
	{ yyval.colV=col_ga; }
break;
case 280:
#line 889 "cmd.y"
	{ yyval.colV=col_set; }
break;
case 281:
#line 892 "cmd.y"
	{ yyval.gaeV=gae_abs; }
break;
case 282:
#line 893 "cmd.y"
	{ yyval.gaeV=gae_sqr; }
break;
case 283:
#line 894 "cmd.y"
	{ yyval.gaeV=gae_perc; }
break;
case 284:
#line 895 "cmd.y"
	{ yyval.gaeV=gae_sqrperc; }
break;
case 285:
#line 896 "cmd.y"
	{ yyval.gaeV=gae_maxperc; }
break;
case 286:
#line 897 "cmd.y"
	{ yyval.gaeV=gae_norm; }
break;
case 287:
#line 900 "cmd.y"
	{ yyval.gapV=gap_and; }
break;
case 288:
#line 901 "cmd.y"
	{ yyval.gapV=gap_or; }
break;
case 289:
#line 902 "cmd.y"
	{ yyval.gapV=gap_custom; }
break;
case 290:
#line 905 "cmd.y"
	{}
break;
case 291:
#line 906 "cmd.y"
	{}
break;
case 292:
#line 910 "cmd.y"
	{
  add_var(&tmp_vars, yystack.l_mark[0].strV, FALSE, 0);
  add_var(&variables, yystack.l_mark[0].strV, FALSE, 0);
}
break;
case 293:
#line 918 "cmd.y"
	{
  list_of_str *sl, *slt;

  slt = NULL;
  for (sl=yystack.l_mark[0].strL; sl!=NULL; sl=sl->prev) {
    sl->next = slt;
    slt = sl;
  }
  yyval.strL = slt;
}
break;
case 294:
#line 931 "cmd.y"
	{
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  strcpy(yyval.strL->str, yystack.l_mark[0].strV);
  yyval.strL->prev = yystack.l_mark[-2].strL;
}
break;
case 295:
#line 938 "cmd.y"
	{
  Str255 s;
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  sprintf(s, "%lf", yystack.l_mark[0].doubV);
  strcpy(yyval.strL->str, s);
  yyval.strL->prev = yystack.l_mark[-2].strL;
}
break;
case 296:
#line 947 "cmd.y"
	{
  Str255 s;
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  sprintf(s, "%d", (int)yystack.l_mark[0].intV);
  strcpy(yyval.strL->str, s);
  yyval.strL->prev = yystack.l_mark[-2].strL;
}
break;
case 297:
#line 956 "cmd.y"
	{
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  strcpy(yyval.strL->str, "?");
  yyval.strL->prev = yystack.l_mark[-2].strL;
}
break;
case 298:
#line 963 "cmd.y"
	{
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  strcpy(yyval.strL->str, yystack.l_mark[0].strV);
  yyval.strL->prev = NULL;
}
break;
case 299:
#line 970 "cmd.y"
	{
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  strcpy(yyval.strL->str, "?");
  yyval.strL->prev = NULL;
}
break;
case 300:
#line 977 "cmd.y"
	{
  Str255 s;
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  sprintf(s, "%d", (int)yystack.l_mark[0].doubV);
  strcpy(yyval.strL->str, s);
  yyval.strL->prev = NULL;
}
break;
case 301:
#line 986 "cmd.y"
	{
  Str255 s;
  yyval.strL = (list_of_str *) malloc(sizeof(*yyval.strL));
  if (yyval.strL==NULL) printf("out of mem\n");
  sprintf(s, "%d", (int)yystack.l_mark[0].intV);
  strcpy(yyval.strL->str, s);
  yyval.strL->prev = NULL;
}
break;
case 302:
#line 997 "cmd.y"
	{
  list_of_num *sl, *slt;

  slt = NULL;
  for (sl=yystack.l_mark[0].numL; sl!=NULL; sl=sl->prev) {
    sl->next = slt;
    slt = sl;
  }
  yyval.numL = slt;
}
break;
case 303:
#line 1010 "cmd.y"
	{
  yyval.numL = (list_of_num *) malloc(sizeof(*yyval.numL));
  yyval.numL->num = yystack.l_mark[0].doubV;
  yyval.numL->prev = yystack.l_mark[-2].numL;
}
break;
case 304:
#line 1016 "cmd.y"
	{
  yyval.numL = (list_of_num *) malloc(sizeof(*yyval.numL));
  yyval.numL->num = yystack.l_mark[0].doubV;
  yyval.numL->prev = NULL;
}
break;
case 314:
#line 1028 "cmd.y"
	{
  list_of_vars *sl, *slt;

  slt = NULL;
  for (sl=yystack.l_mark[0].varL; sl!=NULL; sl=sl->prev) {
    sl->next = slt;
    slt = sl;
  }
  yyval.varL = slt;
}
break;
case 315:
#line 1041 "cmd.y"
	{
  var_type *v;
  v = find_var(variables,yystack.l_mark[0].strV);
  if (v==NULL) {
    printf("error: %s not found\n", yystack.l_mark[0].strV);
    yyval.varL = yystack.l_mark[-2].varL;
  }
  else {
    yyval.varL = (list_of_vars *) malloc(sizeof(*yyval.varL));
    yyval.varL->var = v;
    yyval.varL->prev = yystack.l_mark[-2].varL;
  }
}
break;
case 316:
#line 1055 "cmd.y"
	{
  var_type *v;
  v = find_var(variables,yystack.l_mark[0].strV);
  if (v==NULL) {
    printf("error: %s not found\n", yystack.l_mark[0].strV);
    yyval.varL = NULL;
  }
  else {
    yyval.varL = (list_of_vars *) malloc(sizeof(*yyval.varL));
    yyval.varL->var = v;
    yyval.varL->prev = NULL;;
  }
}
break;
case 317:
#line 1070 "cmd.y"
	{
  yystack.l_mark[0].strQ->next = yystack.l_mark[-2].strQ;
  yyval.strQ = yystack.l_mark[0].strQ;
}
break;
case 318:
#line 1075 "cmd.y"
	{
  yyval.strQ = yystack.l_mark[0].strQ;
}
break;
case 319:
#line 1081 "cmd.y"
	{
  yyval.strQ = (list_of_q *) malloc(sizeof(*yyval.strQ));
  strcpy(yyval.strQ->desc, yystack.l_mark[-2].strV);
  yyval.strQ->degree = yystack.l_mark[0].doubV;
  yyval.strQ->next = NULL;
}
break;
case 320:
#line 1088 "cmd.y"
	{
  Str255 s;
  yyval.strQ = (list_of_q *) malloc(sizeof(*yyval.strQ));
  sprintf(s, "%d", (int)yystack.l_mark[-2].doubV);
  strcpy(yyval.strQ->desc, s);
  yyval.strQ->degree = yystack.l_mark[0].doubV;
  yyval.strQ->next = NULL;
}
break;
case 325:
#line 1116 "cmd.y"
	{
  int j;

  if (att_num == cfam->n_in) {
    for (j=0; j<cfam->out->ndesc 
	 && strcmp(cfam->out->desc[j].name, yystack.l_mark[0].strV);
	 j++);
    if (j<cfam->out->ndesc) set_rule(cfam, att, j, man);
    else {
      printf("error %d: %s not legal qval for %s\n", 
	     yylineno, yystack.l_mark[0].strV, cfam->out->name);
      exit(1);
    }

    att_num = 0;
  }
  else {
    if (!strcmp(yystack.l_mark[0].strV,"?")) {
      att[att_num] = CUNDEF;
    }
    else {
      for (j=0; j<cfam->in[att_num]->ndesc 
	   && strcmp(cfam->in[att_num]->desc[j].name, yystack.l_mark[0].strV);
	   j++);
      if (j<cfam->in[att_num]->ndesc) att[att_num] = j;
      else {
	printf("error_ %d: %s not legal qval for %s\n", 
	       yylineno, yystack.l_mark[0].strV, cfam->in[att_num]->name);
      }
    }
    att_num++;
  }
}
break;
case 330:
#line 1164 "cmd.y"
	{
  int j;

  if (att_num == cfam->n_in) {
    if (yystack.l_mark[0].intV<0 || yystack.l_mark[0].intV>=cfam->out->ndesc) {
      printf("error i %d: index %d not legal for %s\n", 
	     yylineno, yystack.l_mark[0].intV, cfam->out->name);
      exit(1);
    }
    set_rule(cfam, att, yystack.l_mark[0].intV, man);
    att_num = 0;
  }
  else {
/*    if ($1==CUNDEF)
      att[att_num] = $1; */
    if (yystack.l_mark[0].intV<0 || yystack.l_mark[0].intV>=cfam->in[att_num]->ndesc) {
      printf("error j %d: index %d not legal for %s\n", 
	     yylineno, yystack.l_mark[0].intV, cfam->in[att_num]->name);
      exit(0);
    }
    else
      att[att_num] = yystack.l_mark[0].intV;
    att_num++;
  }
}
break;
case 331:
#line 1195 "cmd.y"
	{ strcpy(yyval.strV,yystack.l_mark[0].strV); }
break;
case 332:
#line 1196 "cmd.y"
	{ Str255 s; sprintf(s, "%lf", (int)yystack.l_mark[0].doubV); strcpy(yyval.strV,s);}
break;
case 333:
#line 1197 "cmd.y"
	{ Str255 s; sprintf(s, "%d", (int)yystack.l_mark[0].intV); strcpy(yyval.strV,s);}
break;
case 334:
#line 1198 "cmd.y"
	{ strcpy(yyval.strV,"?"); }
break;
case 335:
#line 1201 "cmd.y"
	{ yyval.doubV = yystack.l_mark[0].doubV; }
break;
case 336:
#line 1202 "cmd.y"
	{ yyval.doubV = yystack.l_mark[0].intV; }
break;
case 337:
#line 1205 "cmd.y"
	{
  if (cfam==NULL)
    printf("error: no FAM current\n");
  else {
    if (att!=NULL) free(att);
    att = c_vector(cfam->n_in);
  }
}
break;
case 338:
#line 1215 "cmd.y"
	{ yyval.erV = er_table; }
break;
case 339:
#line 1216 "cmd.y"
	{ yyval.erV = er_list; }
break;
case 340:
#line 1217 "cmd.y"
	{ yyval.erV = er_tree; }
break;
#line 3186 "y.tab.c"
    }
    yystack.s_mark -= yym;
    yystate = *yystack.s_mark;
    yystack.l_mark -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yystack.s_mark = YYFINAL;
        *++yystack.l_mark = yyval;
        if (yychar < 0)
        {
            if ((yychar = YYLEX) < 0) yychar = YYEOF;
#if YYDEBUG
            if (yydebug)
            {
                yys = yyname[YYTRANSLATE(yychar)];
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == YYEOF) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yystack.s_mark, yystate);
#endif
    if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
    {
        goto yyoverflow;
    }
    *++yystack.s_mark = (YYINT) yystate;
    *++yystack.l_mark = yyval;
    goto yyloop;

yyoverflow:
    YYERROR_CALL("yacc stack overflow");

yyabort:
    yyfreestack(&yystack);
    return (1);

yyaccept:
    yyfreestack(&yystack);
    return (0);
}
